{"/api-reference/functions":{"title":"API Reference","data":{"":"Complete reference for all lit functions and types.","registration#Registration":"","registermodel#RegisterModel":"Registers a model with the default naming strategy.\nfunc RegisterModel[T any](driver Driver)\nParameters:\ndriver: Database driver (lit.PostgreSQL or lit.MySQL)\nExample:\nlit.RegisterModel[User](lit.PostgreSQL)","registerdriver#RegisterDriver":"Sets the default database driver for model registration.\nfunc RegisterDriver(driver Driver)\nParameters:\ndriver: Database driver (lit.PostgreSQL or lit.MySQL)\nExample:\nlit.RegisterDriver(lit.PostgreSQL)","registermodelwithnaming#RegisterModelWithNaming":"Registers a model with a custom naming strategy.\nfunc RegisterModelWithNaming[T any](driver Driver, namingStrategy DbNamingStrategy)\nParameters:\ndriver: Database driver\nnamingStrategy: Implementation of DbNamingStrategy\nExample:\nlit.RegisterModelWithNaming[User](lit.PostgreSQL, MyNamingStrategy{})","query-functions#Query Functions":"","select#Select":"Executes a query and returns all matching rows.\nfunc Select[T any](ex Executor, query string, args ...any) ([]*T, error)\nParameters:\nex: Database connection or transaction\nquery: SQL SELECT query\nargs: Query parameters\nReturns:\n[]*T: Slice of pointers to results\nerror: Any error that occurred\nExample:\nusers, err := lit.Select[User](db, \"SELECT id, name, email FROM users WHERE active = $1\", true)","selectsingle#SelectSingle":"Executes a query and returns a single row or nil.\nfunc SelectSingle[T any](ex Executor, query string, args ...any) (*T, error)\nParameters:\nex: Database connection or transaction\nquery: SQL SELECT query\nargs: Query parameters\nReturns:\n*T: Pointer to result, or nil if not found\nerror: Any error that occurred\nExample:\nuser, err := lit.SelectSingle[User](db, \"SELECT id, name, email FROM users WHERE id = $1\", 123)","selectnamed#SelectNamed":"Parses :name placeholders and executes a SELECT returning all matching rows.\nfunc SelectNamed[T any](ex Executor, query string, params map[string]any) ([]*T, error)\nParameters:\nex: Database connection or transaction\nquery: SQL SELECT query with :name placeholders\nparams: Map of parameter names to values\nReturns:\n[]*T: Slice of pointers to results\nerror: Any error (including missing parameters)\nExample:\nusers, err := lit.SelectNamed[User](db,\n    \"SELECT * FROM users WHERE last_name = :last_name\",\n    lit.P{\"last_name\": \"Doe\"})","selectsinglenamed#SelectSingleNamed":"Parses :name placeholders and executes a SELECT returning a single row or nil.\nfunc SelectSingleNamed[T any](ex Executor, query string, params map[string]any) (*T, error)\nParameters:\nex: Database connection or transaction\nquery: SQL SELECT query with :name placeholders\nparams: Map of parameter names to values\nReturns:\n*T: Pointer to result, or nil if not found\nerror: Any error (including missing parameters)\nExample:\nuser, err := lit.SelectSingleNamed[User](db,\n    \"SELECT * FROM users WHERE id = :id\",\n    lit.P{\"id\": 123})","selectmultiplenative#SelectMultipleNative":"Executes a query with manual row scanning.\nfunc SelectMultipleNative[T any](\n    ex Executor,\n    mapLine func(*interface{ Scan(...any) error }, *T) error,\n    query string,\n    args ...any,\n) ([]*T, error)\nParameters:\nex: Database connection or transaction\nmapLine: Function to scan each row\nquery: SQL SELECT query\nargs: Query parameters\nExample:\nresults, err := lit.SelectMultipleNative[Result](db,\n    func(scanner *interface{ Scan(...any) error }, r *Result) error {\n        return (*scanner).Scan(&r.Name, &r.Value)\n    },\n    \"SELECT name, value FROM items\")","mutation-functions#Mutation Functions":"","insert#Insert":"Inserts a record and returns the generated ID.\nfunc Insert[T any](ex Executor, t *T) (int, error)\nParameters:\nex: Database connection or transaction\nt: Pointer to the struct to insert\nReturns:\nint: Generated ID\nerror: Any error that occurred\nExample:\nid, err := lit.Insert(db, &user)","insertuuid#InsertUuid":"Inserts a record with an auto-generated UUID.\nfunc InsertUuid[T any](ex Executor, t *T) (string, error)\nParameters:\nex: Database connection or transaction\nt: Pointer to the struct to insert (Id field will be set)\nReturns:\nstring: Generated UUID\nerror: Any error that occurred\nExample:\nuuid, err := lit.InsertUuid(db, &session)","insertexistinguuid#InsertExistingUuid":"Inserts a record with a pre-existing UUID.\nfunc InsertExistingUuid[T any](ex Executor, t *T) error\nParameters:\nex: Database connection or transaction\nt: Pointer to the struct to insert (Id must be set)\nReturns:\nerror: Any error that occurred\nExample:\nerr := lit.InsertExistingUuid(db, &session)","insertnative#InsertNative":"Executes a manual INSERT query.\nfunc InsertNative(ex Executor, query string, args ...any) (int, error)\nParameters:\nex: Database connection or transaction\nquery: SQL INSERT query\nargs: Query parameters\nReturns:\nint: Last inserted ID\nerror: Any error that occurred","update#Update":"Updates a record with a WHERE clause.\nfunc Update[T any](ex Executor, t *T, where string, args ...any) error\nParameters:\nex: Database connection or transaction\nt: Pointer to the struct with updated values\nwhere: WHERE clause (required, cannot be empty)\nargs: WHERE clause parameters\nReturns:\nerror: Any error that occurred\nExample:\nerr := lit.Update(db, &user, \"id = $1\", user.Id)","updatenamed#UpdateNamed":"Updates a record with a named-parameter WHERE clause.\nfunc UpdateNamed[T any](ex Executor, t *T, where string, params map[string]any) error\nParameters:\nex: Database connection or transaction\nt: Pointer to the struct with updated values\nwhere: WHERE clause with :name placeholders (required)\nparams: Map of parameter names to values\nReturns:\nerror: Any error (including missing parameters)\nExample:\nuser.Email = \"jane@example.com\"\nerr := lit.UpdateNamed(db, &user, \"id = :id\", lit.P{\"id\": user.Id})","updatenative#UpdateNative":"Executes a manual UPDATE query.\nfunc UpdateNative(ex Executor, query string, args ...any) error\nParameters:\nex: Database connection or transaction\nquery: SQL UPDATE query\nargs: Query parameters","delete#Delete":"Executes a DELETE query.\nfunc Delete(ex Executor, query string, args ...any) error\nParameters:\nex: Database connection or transaction\nquery: SQL DELETE query\nargs: Query parameters\nExample:\nerr := lit.Delete(db, \"DELETE FROM users WHERE id = $1\", 123)","deletenamed#DeleteNamed":"Parses :name placeholders and executes a DELETE query.\nfunc DeleteNamed(driver Driver, ex Executor, query string, params map[string]any) error\nParameters:\ndriver: Database driver (required because Delete is non-generic)\nex: Database connection or transaction\nquery: SQL DELETE query with :name placeholders\nparams: Map of parameter names to values\nReturns:\nerror: Any error (including missing parameters)\nExample:\nerr := lit.DeleteNamed(lit.PostgreSQL, db,\n    \"DELETE FROM users WHERE id = :id\",\n    lit.P{\"id\": 123})","named-parameter-parsing#Named Parameter Parsing":"","parsenamedquery#ParseNamedQuery":"Low-level parser that converts :name placeholders to driver-specific positional syntax.\nfunc ParseNamedQuery(driver Driver, query string, params map[string]any) (string, []any, error)\nParameters:\ndriver: Database driver (lit.PostgreSQL, lit.MySQL, or lit.SQLite)\nquery: SQL query with :name placeholders\nparams: Map of parameter names to values\nReturns:\nstring: Transformed query with positional placeholders\n[]any: Ordered argument slice\nerror: Any error (unsupported driver, missing parameter)\nExample:\nquery, args, err := lit.ParseNamedQuery(lit.PostgreSQL,\n    \"SELECT * FROM users WHERE id = :id AND name = :name\",\n    lit.P{\"id\": 1, \"name\": \"John\"})\n// query = \"SELECT * FROM users WHERE id = $1 AND name = $2\"\n// args = [1, \"John\"]","parsenamedqueryformodel#ParseNamedQueryForModel":"Like ParseNamedQuery but infers the driver from the model's registration.\nfunc ParseNamedQueryForModel[T any](query string, params map[string]any) (string, []any, error)\nParameters:\nquery: SQL query with :name placeholders\nparams: Map of parameter names to values\nReturns:\nstring: Transformed query with positional placeholders\n[]any: Ordered argument slice\nerror: Any error (unregistered model, missing parameter)\nExample:\nquery, args, err := lit.ParseNamedQueryForModel[User](\n    \"SELECT * FROM users WHERE id = :id\",\n    lit.P{\"id\": 1})","helper-functions#Helper Functions":"","joinforin#JoinForIn":"Creates a comma-separated string of integers for IN clauses.\nfunc JoinForIn(ids []int) string\nExample:\nids := []int{1, 2, 3}\nquery := \"SELECT * FROM users WHERE id IN (\" + lit.JoinForIn(ids) + \")\"\n// Result: SELECT * FROM users WHERE id IN (1,2,3)","joinstringforin#JoinStringForIn":"Creates parameterized placeholders for IN clauses.\nfunc JoinStringForIn[T any](offset int, params []string) string\nParameters:\noffset: Starting parameter number (for PostgreSQL)\nparams: Slice of values (used to determine count)\nExample:\nemails := []string{\"a@test.com\", \"b@test.com\"}\nplaceholders := lit.JoinStringForIn[User](0, emails)\n// PostgreSQL: $1,$2\n// MySQL: ?,?","joinstringforinwithdriver#JoinStringForInWithDriver":"Creates parameterized placeholders for a specific driver.\nfunc JoinStringForInWithDriver(driver Driver, offset int, count int) string\nExample:\nplaceholders := lit.JoinStringForInWithDriver(lit.PostgreSQL, 2, 3)\n// Result: $3,$4,$5","types#Types":"","p#P":"Shorthand type alias for named parameter maps.\ntype P = map[string]any\nP is a true alias (using =), so it is fully interchangeable with map[string]any — no conversion needed.Example:\n// Instead of map[string]any{\"id\": 1}\nusers, err := lit.SelectNamed[User](db,\n    \"SELECT * FROM users WHERE id = :id\",\n    lit.P{\"id\": 1})","driver#Driver":"Database driver enum.\ntype Driver int\nconst (\n    PostgreSQL Driver = iota\n    MySQL\n)","executor#Executor":"Interface for database operations (implemented by *sql.DB and *sql.Tx).\ntype Executor interface {\n    Exec(query string, args ...any) (sql.Result, error)\n    Query(query string, args ...any) (*sql.Rows, error)\n    QueryRow(query string, args ...any) *sql.Row\n}","dbnamingstrategy#DbNamingStrategy":"Interface for custom naming conventions.\ntype DbNamingStrategy interface {\n    GetTableNameFromStructName(string) string\n    GetColumnNameFromStructName(string) string\n}","defaultdbnamingstrategy#DefaultDbNamingStrategy":"Built-in naming strategy (CamelCase → snake_case).\ntype DefaultDbNamingStrategy struct{}","fieldmap#FieldMap":"Cached metadata for a registered model.\ntype FieldMap struct {\n    ColumnsMap    map[string]int  // Column name → field index\n    ColumnKeys    []string        // Ordered column names\n    HasIntId      bool            // Whether id is an integer\n    InsertQuery   string          // Pre-built INSERT query\n    UpdateQuery   string          // Pre-built UPDATE query (without WHERE)\n    InsertColumns []string        // Columns used in INSERT\n    Driver        Driver          // Database driver\n}"}},"/core-concepts/queries":{"title":"Queries","data":{"":"lit provides two functions for reading data: Select for multiple rows and SelectSingle for a single row.","select#Select":"Returns all matching rows as a slice of pointers:\nfunc Select[T any](ex Executor, query string, args ...any) ([]*T, error)","example#Example":"// Get all users\nusers, err := lit.Select[User](db, \"SELECT id, first_name, last_name, email FROM users\")\nif err != nil {\n    return err\n}\nfor _, user := range users {\n    fmt.Printf(\"%s %s\\n\", user.FirstName, user.LastName)\n}","with-parameters#With Parameters":"// PostgreSQL\nusers, err := lit.Select[User](db,\n    \"SELECT id, first_name, last_name, email FROM users WHERE last_name = $1\",\n    \"Doe\")\n// MySQL\nusers, err := lit.Select[User](db,\n    \"SELECT id, first_name, last_name, email FROM users WHERE last_name = ?\",\n    \"Doe\")","selectsingle#SelectSingle":"Returns a single row or nil if not found:\nfunc SelectSingle[T any](ex Executor, query string, args ...any) (*T, error)","example-1#Example":"user, err := lit.SelectSingle[User](db,\n    \"SELECT id, first_name, last_name, email FROM users WHERE id = $1\", id)\nif err != nil {\n    return err\n}\nif user == nil {\n    fmt.Println(\"User not found\")\n    return nil\n}\nfmt.Printf(\"Found: %s\\n\", user.Email)","named-parameters#Named Parameters":"Write portable queries with :name placeholders instead of driver-specific $1 or ?. lit parses them and converts to the correct syntax automatically.","selectnamed#SelectNamed":"func SelectNamed[T any](ex Executor, query string, params map[string]any) ([]*T, error)\n// This query works on PostgreSQL, MySQL, and SQLite — no changes needed\nusers, err := lit.SelectNamed[User](db,\n    \"SELECT * FROM users WHERE last_name = :last_name AND email = :email\",\n    lit.P{\"last_name\": \"Doe\", \"email\": \"john@example.com\"})","selectsinglenamed#SelectSingleNamed":"func SelectSingleNamed[T any](ex Executor, query string, params map[string]any) (*T, error)\nuser, err := lit.SelectSingleNamed[User](db,\n    \"SELECT * FROM users WHERE id = :id\",\n    lit.P{\"id\": 1})\nif err != nil {\n    return err\n}\nif user == nil {\n    fmt.Println(\"User not found\")\n}","error-on-missing-parameters#Error on Missing Parameters":"If a :name placeholder has no matching key in the params map, the function returns an error without executing the query:\n_, err := lit.SelectNamed[User](db,\n    \"SELECT * FROM users WHERE id = :id AND email = :email\",\n    lit.P{\"id\": 1})\n// Error: missing parameter: email","manual-parsing#Manual Parsing":"For advanced use, you can parse named queries yourself and then call any operation:\n// Infer driver from registered model\nquery, args, err := lit.ParseNamedQueryForModel[User](\n    \"SELECT * FROM users WHERE id = :id\", lit.P{\"id\": 1})\n// Or specify driver explicitly\nquery, args, err := lit.ParseNamedQuery(lit.PostgreSQL,\n    \"SELECT * FROM users WHERE id = :id\", lit.P{\"id\": 1})\n// query = \"SELECT * FROM users WHERE id = $1\", args = [1]\nThe parser correctly handles PostgreSQL :: type casts, single-quoted string literals, and repeated parameters.","column-validation#Column Validation":"lit validates that all columns in your SELECT match fields in your struct. This catches errors early:\n// This will return an error if 'nonexistent' is not a field in User\nusers, err := lit.Select[User](db,\n    \"SELECT id, first_name, nonexistent FROM users\")\n// Error: invalid column that is not found in the struct: nonexistent","projections-dtos#Projections (DTOs)":"You can project query results into any struct, not just your registered models. This is useful for:\nSelecting only specific columns\nJOINs that combine multiple tables\nAggregations","partial-select#Partial Select":"type UserSummary struct {\n    Id    int\n    Email string\n}\nlit.RegisterModel[UserSummary](lit.PostgreSQL)\nsummaries, err := lit.Select[UserSummary](db,\n    \"SELECT id, email FROM users\")","join-results#JOIN Results":"type UserWithOrder struct {\n    UserId    int\n    UserEmail string\n    OrderId   int\n    Total     float64\n}\nlit.RegisterModel[UserWithOrder](lit.PostgreSQL)\nresults, err := lit.Select[UserWithOrder](db, `\n    SELECT\n        u.id as user_id,\n        u.email as user_email,\n        o.id as order_id,\n        o.total\n    FROM users u\n    JOIN orders o ON o.user_id = u.id\n    WHERE o.total > $1`, 100.00)\nSee Projections & DTOs for more examples.","native-queries#Native Queries":"For complex scenarios where automatic mapping doesn't work, use SelectMultipleNative:\nfunc SelectMultipleNative[T any](\n    ex Executor,\n    mapLine func(*interface{ Scan(...any) error }, *T) error,\n    query string,\n    args ...any,\n) ([]*T, error)\nThis gives you full control over the scanning process:\ntype CustomResult struct {\n    Name  string\n    Count int\n}\nresults, err := lit.SelectMultipleNative[CustomResult](db,\n    func(scanner *interface{ Scan(...any) error }, r *CustomResult) error {\n        return (*scanner).Scan(&r.Name, &r.Count)\n    },\n    \"SELECT name, COUNT(*) FROM items GROUP BY name\")"}},"/core-concepts/transactions":{"title":"Transactions","data":{"":"lit works seamlessly with database transactions through the Executor interface.","the-executor-interface#The Executor Interface":"All lit functions accept an Executor:\ntype Executor interface {\n    Exec(query string, args ...any) (sql.Result, error)\n    Query(query string, args ...any) (*sql.Rows, error)\n    QueryRow(query string, args ...any) *sql.Row\n}\nBoth *sql.DB and *sql.Tx implement this interface, so you can use the same code with or without transactions.","basic-transaction-pattern#Basic Transaction Pattern":"func CreateUserWithProfile(db *sql.DB, user *User, profile *Profile) error {\n    tx, err := db.Begin()\n    if err != nil {\n        return err\n    }\n    defer tx.Rollback() // No-op if committed\n    // Insert user\n    userId, err := lit.Insert(tx, user)\n    if err != nil {\n        return err\n    }\n    // Insert profile with user ID\n    profile.UserId = userId\n    _, err = lit.Insert(tx, profile)\n    if err != nil {\n        return err\n    }\n    return tx.Commit()\n}","repository-pattern#Repository Pattern":"A common pattern is to accept an Executor in your repository methods:\ntype UserRepository struct{}\nfunc (r *UserRepository) Create(ex lit.Executor, user *User) (int, error) {\n    return lit.Insert(ex, user)\n}\nfunc (r *UserRepository) FindById(ex lit.Executor, id int) (*User, error) {\n    return lit.SelectSingle[User](ex,\n        \"SELECT id, first_name, last_name, email FROM users WHERE id = $1\", id)\n}\nfunc (r *UserRepository) Update(ex lit.Executor, user *User) error {\n    return lit.Update(ex, user, \"id = $1\", user.Id)\n}\nfunc (r *UserRepository) Delete(ex lit.Executor, id int) error {\n    return lit.Delete(ex, \"DELETE FROM users WHERE id = $1\", id)\n}","usage-without-transaction#Usage Without Transaction":"repo := &UserRepository{}\nuser, err := repo.FindById(db, 123)","usage-with-transaction#Usage With Transaction":"repo := &UserRepository{}\ntx, err := db.Begin()\nif err != nil {\n    return err\n}\ndefer tx.Rollback()\nuser, err := repo.FindById(tx, 123)\nif err != nil {\n    return err\n}\nuser.Email = \"new@example.com\"\nif err := repo.Update(tx, user); err != nil {\n    return err\n}\nreturn tx.Commit()","complete-example#Complete Example":"type OrderService struct {\n    db        *sql.DB\n    users     *UserRepository\n    orders    *OrderRepository\n    inventory *InventoryRepository\n}\nfunc (s *OrderService) PlaceOrder(userId int, items []OrderItem) error {\n    tx, err := s.db.Begin()\n    if err != nil {\n        return err\n    }\n    defer tx.Rollback()\n    // Verify user exists\n    user, err := s.users.FindById(tx, userId)\n    if err != nil {\n        return err\n    }\n    if user == nil {\n        return errors.New(\"user not found\")\n    }\n    // Create order\n    order := &Order{UserId: userId, Status: \"pending\"}\n    orderId, err := s.orders.Create(tx, order)\n    if err != nil {\n        return err\n    }\n    // Add items and update inventory\n    for _, item := range items {\n        item.OrderId = orderId\n        if _, err := s.orders.AddItem(tx, &item); err != nil {\n            return err\n        }\n        if err := s.inventory.Decrement(tx, item.ProductId, item.Quantity); err != nil {\n            return err\n        }\n    }\n    return tx.Commit()\n}","error-handling#Error Handling":"The deferred Rollback() pattern is safe because:\nIf Commit() succeeds, Rollback() is a no-op\nIf any error occurs before Commit(), the transaction is rolled back\nIf Commit() fails, the transaction is also rolled back\ntx, err := db.Begin()\nif err != nil {\n    return err\n}\ndefer tx.Rollback() // Safe: no-op after successful commit\n// ... operations ...\nif err := tx.Commit(); err != nil {\n    // Rollback already called by defer\n    return fmt.Errorf(\"failed to commit: %w\", err)\n}\nreturn nil"}},"/examples/crud-repository":{"title":"CRUD Repository Example","data":{"":"A complete example implementing the repository pattern with lit.","project-structure#Project Structure":"myapp/\n├── main.go\n├── models/\n│   └── user.go\n├── repositories/\n│   └── user_repository.go\n└── go.mod","model-definition#Model Definition":"// models/user.go\npackage models\nimport \"time\"\ntype User struct {\n    Id        int\n    FirstName string\n    LastName  string\n    Email     string\n    Active    bool\n    CreatedAt time.Time\n    UpdatedAt time.Time\n}","repository-implementation#Repository Implementation":"// repositories/user_repository.go\npackage repositories\nimport (\n    \"myapp/models\"\n    \"time\"\n    \"github.com/tracewayapp/go-lightning/lit\"\n)\ntype UserRepository struct{}\n// Create inserts a new user and returns the generated ID\nfunc (r *UserRepository) Create(ex lit.Executor, user *models.User) (int, error) {\n    user.CreatedAt = time.Now()\n    user.UpdatedAt = time.Now()\n    user.Active = true\n    return lit.Insert(ex, user)\n}\n// FindById retrieves a user by ID, returns nil if not found\nfunc (r *UserRepository) FindById(ex lit.Executor, id int) (*models.User, error) {\n    return lit.SelectSingle[models.User](ex,\n        `SELECT id, first_name, last_name, email, active, created_at, updated_at\n         FROM users WHERE id = $1`, id)\n}\n// FindByEmail retrieves a user by email, returns nil if not found\nfunc (r *UserRepository) FindByEmail(ex lit.Executor, email string) (*models.User, error) {\n    return lit.SelectSingle[models.User](ex,\n        `SELECT id, first_name, last_name, email, active, created_at, updated_at\n         FROM users WHERE email = $1`, email)\n}\n// FindAll retrieves all users\nfunc (r *UserRepository) FindAll(ex lit.Executor) ([]*models.User, error) {\n    return lit.Select[models.User](ex,\n        `SELECT id, first_name, last_name, email, active, created_at, updated_at\n         FROM users ORDER BY id`)\n}\n// FindActive retrieves all active users\nfunc (r *UserRepository) FindActive(ex lit.Executor) ([]*models.User, error) {\n    return lit.Select[models.User](ex,\n        `SELECT id, first_name, last_name, email, active, created_at, updated_at\n         FROM users WHERE active = true ORDER BY id`)\n}\n// FindByIds retrieves users by a list of IDs\nfunc (r *UserRepository) FindByIds(ex lit.Executor, ids []int) ([]*models.User, error) {\n    if len(ids) == 0 {\n        return []*models.User{}, nil\n    }\n    return lit.Select[models.User](ex,\n        `SELECT id, first_name, last_name, email, active, created_at, updated_at\n         FROM users WHERE id IN (`+lit.JoinForIn(ids)+`) ORDER BY id`)\n}\n// Update updates an existing user\nfunc (r *UserRepository) Update(ex lit.Executor, user *models.User) error {\n    user.UpdatedAt = time.Now()\n    return lit.Update(ex, user, \"id = $1\", user.Id)\n}\n// Delete removes a user by ID\nfunc (r *UserRepository) Delete(ex lit.Executor, id int) error {\n    return lit.Delete(ex, \"DELETE FROM users WHERE id = $1\", id)\n}\n// SoftDelete marks a user as inactive\nfunc (r *UserRepository) SoftDelete(ex lit.Executor, id int) error {\n    return lit.UpdateNative(ex,\n        \"UPDATE users SET active = false, updated_at = $1 WHERE id = $2\",\n        time.Now(), id)\n}\n// Count returns the total number of users\nfunc (r *UserRepository) Count(ex lit.Executor) (int, error) {\n    type CountResult struct {\n        Count int\n    }\n    result, err := lit.SelectSingle[CountResult](ex, \"SELECT COUNT(*) as count FROM users\")\n    if err != nil {\n        return 0, err\n    }\n    return result.Count, nil\n}\n// Exists checks if a user with the given email exists\nfunc (r *UserRepository) Exists(ex lit.Executor, email string) (bool, error) {\n    type ExistsResult struct {\n        Exists bool\n    }\n    result, err := lit.SelectSingle[ExistsResult](ex,\n        \"SELECT EXISTS(SELECT 1 FROM users WHERE email = $1) as exists\", email)\n    if err != nil {\n        return false, err\n    }\n    return result.Exists, nil\n}","main-application#Main Application":"// main.go\npackage main\nimport (\n    \"database/sql\"\n    \"fmt\"\n    \"log\"\n    \"myapp/models\"\n    \"myapp/repositories\"\n    \"github.com/tracewayapp/go-lightning/lit\"\n    _ \"github.com/lib/pq\"\n)\nfunc init() {\n    // Register default driver\n    lit.RegisterDriver(lit.PostgreSQL)\n    // Register models at startup\n    lit.RegisterModel[models.User]()\n    // Register helper structs for queries\n    type CountResult struct{ Count int }\n    type ExistsResult struct{ Exists bool }\n    lit.RegisterModel[CountResult]()\n    lit.RegisterModel[ExistsResult]()\n}\nfunc main() {\n    // Connect to database\n    db, err := sql.Open(\"postgres\", \"postgres://localhost/mydb?sslmode=disable\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer db.Close()\n    // Create repository\n    userRepo := &repositories.UserRepository{}\n    // Create a user\n    user := &models.User{\n        FirstName: \"John\",\n        LastName:  \"Doe\",\n        Email:     \"john@example.com\",\n    }\n    id, err := userRepo.Create(db, user)\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Printf(\"Created user with ID: %d\\n\", id)\n    // Find by ID\n    found, err := userRepo.FindById(db, id)\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Printf(\"Found: %s %s\\n\", found.FirstName, found.LastName)\n    // Update\n    found.FirstName = \"Jane\"\n    if err := userRepo.Update(db, found); err != nil {\n        log.Fatal(err)\n    }\n    fmt.Println(\"Updated user\")\n    // List all\n    users, err := userRepo.FindAll(db)\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Printf(\"Total users: %d\\n\", len(users))\n    // Delete\n    if err := userRepo.Delete(db, id); err != nil {\n        log.Fatal(err)\n    }\n    fmt.Println(\"Deleted user\")\n}","database-schema#Database Schema":"CREATE TABLE IF NOT EXISTS users (\n    id SERIAL PRIMARY KEY,\n    first_name TEXT NOT NULL,\n    last_name TEXT NOT NULL,\n    email TEXT UNIQUE NOT NULL,\n    active BOOLEAN DEFAULT true,\n    created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n    updated_at TIMESTAMP NOT NULL DEFAULT NOW()\n);\nCREATE INDEX idx_users_email ON users(email);\nCREATE INDEX idx_users_active ON users(active);","using-with-transactions#Using with Transactions":"func CreateUserWithProfile(db *sql.DB, userRepo *repositories.UserRepository, profileRepo *repositories.ProfileRepository) error {\n    tx, err := db.Begin()\n    if err != nil {\n        return err\n    }\n    defer tx.Rollback()\n    // Create user\n    user := &models.User{\n        FirstName: \"John\",\n        LastName:  \"Doe\",\n        Email:     \"john@example.com\",\n    }\n    userId, err := userRepo.Create(tx, user)\n    if err != nil {\n        return err\n    }\n    // Create profile\n    profile := &models.Profile{\n        UserId: userId,\n        Bio:    \"Hello, world!\",\n    }\n    _, err = profileRepo.Create(tx, profile)\n    if err != nil {\n        return err\n    }\n    return tx.Commit()\n}","mysql-version#MySQL Version":"For MySQL, change the placeholder syntax:\nfunc (r *UserRepository) FindById(ex lit.Executor, id int) (*models.User, error) {\n    return lit.SelectSingle[models.User](ex,\n        `SELECT id, first_name, last_name, email, active, created_at, updated_at\n         FROM users WHERE id = ?`, id)\n}\nfunc (r *UserRepository) Update(ex lit.Executor, user *models.User) error {\n    user.UpdatedAt = time.Now()\n    return lit.Update(ex, user, \"id = ?\", user.Id)\n}\nfunc (r *UserRepository) Delete(ex lit.Executor, id int) error {\n    return lit.Delete(ex, \"DELETE FROM users WHERE id = ?\", id)\n}\nAnd register with MySQL driver:\nlit.RegisterModel[models.User](lit.MySQL)"}},"/getting-started/installation":{"title":"Installation","data":{"requirements#Requirements":"Go 1.21 or higher\nA supported database (PostgreSQL or MySQL)","install-lit#Install lit":"go get github.com/tracewayapp/go-lightning/lit","database-drivers#Database Drivers":"lit works with standard database/sql drivers. Install the driver for your database:","postgresql#PostgreSQL":"# pgx (recommended)\ngo get github.com/jackc/pgx/v5/stdlib\n# or pq\ngo get github.com/lib/pq","mysql#MySQL":"go get github.com/go-sql-driver/mysql","verify-installation#Verify Installation":"Create a simple program to verify everything is working:\npackage main\nimport (\n    \"fmt\"\n    \"github.com/tracewayapp/go-lightning/lit\"\n)\ntype User struct {\n    Id    int\n    Name  string\n    Email string\n}\nfunc main() {\n    lit.RegisterModel[User](lit.PostgreSQL) // or lit.MySQL\n    fmt.Println(\"lit installed successfully!\")\n}\nRun it:\ngo run main.go\nIf you see \"lit installed successfully!\", you're ready to proceed to the Quick Start."}},"/getting-started/quick-start":{"title":"Quick Start","data":{"":"This guide will get you running with lit in 5 minutes.","1-define-your-model#1. Define Your Model":"Create a struct that maps to your database table:\ntype User struct {\n    Id        int\n    FirstName string\n    LastName  string\n    Email     string\n}\nField names are automatically converted to snake_case column names:\nId → id\nFirstName → first_name\nLastName → last_name","2-create-your-table#2. Create Your Table":"Create the corresponding table in your database:\n-- PostgreSQL\nCREATE TABLE IF NOT EXISTS users (\n    id SERIAL PRIMARY KEY,\n    first_name TEXT NOT NULL,\n    last_name TEXT NOT NULL,\n    email TEXT UNIQUE NOT NULL\n);\n-- MySQL\nCREATE TABLE IF NOT EXISTS users (\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    first_name VARCHAR(255) NOT NULL,\n    last_name VARCHAR(255) NOT NULL,\n    email VARCHAR(255) UNIQUE NOT NULL\n);","3-register-the-model#3. Register the Model":"At application startup, register your model with the appropriate driver:\nimport \"github.com/tracewayapp/go-lightning/lit\"\nfunc init() {\n    lit.RegisterDriver(lit.PostgreSQL) // or lit.MySQL for MySQL\n    lit.RegisterModel[User]()\n    // or lit.RegisterModel[User](lit.PostgreSQL) if not using default driver\n}\nRegistration only happens once and caches INSERT/UPDATE queries for optimal performance.We recommend registering the models in a centralized place that you invoke in your main function:\nimport \"github.com/tracewayapp/go-lightning/lit\"\nfunc RegisterModels() {\n    lit.RegisterDriver(lit.PostgreSQL) // or lit.MySQL\n    lit.RegisterModel[User]()\n    lit.RegisterModel[Invoice]()\n    // ... register other models\n}\nfunc main() {\n    // init config etc...\n    RegisterModels()\n    // start your server/the rest of your application code...\n}","4-connect-to-database#4. Connect to Database":"import (\n    \"database/sql\"\n    _ \"github.com/lib/pq\"  // PostgreSQL driver\n)\ndb, err := sql.Open(\"postgres\", \"postgres://user:pass@localhost/mydb?sslmode=disable\")\nif err != nil {\n    log.Fatal(err)\n}\ndefer db.Close()","5-perform-crud-operations#5. Perform CRUD Operations":"","create#Create":"user := User{\n    FirstName: \"John\",\n    LastName:  \"Doe\",\n    Email:     \"john@example.com\",\n}\nid, err := lit.Insert(db, &user)","read#Read":"// Select all\nusers, err := lit.Select[User](db,\n    \"SELECT id, first_name, last_name, email FROM users\")\n// Select single\nuser, err := lit.SelectSingle[User](db,\n    \"SELECT id, first_name, last_name, email FROM users WHERE id = $1\", id)","update#Update":"user.FirstName = \"Jane\"\nerr := lit.Update(db, &user, \"id = $1\", user.Id)","delete#Delete":"err := lit.Delete(db, \"DELETE FROM users WHERE id = $1\", id)","mysql-differences#MySQL Differences":"When using MySQL, use ? placeholders instead of $1, $2, etc:\n// MySQL uses ? placeholders\nuser, err := lit.SelectSingle[User](db,\n    \"SELECT id, first_name, last_name, email FROM users WHERE id = ?\", id)\nerr := lit.Update(db, &user, \"id = ?\", user.Id)\nerr := lit.Delete(db, \"DELETE FROM users WHERE id = ?\", id)","next-steps#Next Steps":"Learn about Registration and how it optimizes performance\nUnderstand Queries for reading data\nExplore Mutations for writes\nSee a complete CRUD Repository example"}},"/guides/naming-strategies":{"title":"Table & Column Naming","data":{"":"lit converts Go struct and field names to database table and column names using a naming strategy. The default converts CamelCase to snake_case, but you can customize this behavior.","the-dbnamingstrategy-interface#The DbNamingStrategy Interface":"All naming is controlled through this interface:\ntype DbNamingStrategy interface {\n    GetTableNameFromStructName(string) string\n    GetColumnNameFromStructName(string) string\n}\nThe built-in DefaultDbNamingStrategy applies these rules:\nTable names: Struct name → snake_case + \"s\" (pluralized)\nColumn names: Field name → snake_case","column-naming#Column Naming":"","default-column-names#Default Column Names":"Field names are converted from CamelCase to snake_case. Consecutive uppercase letters (acronyms) are kept together:\nField\tColumn\tId\tid\tFirstName\tfirst_name\tCreatedAt\tcreated_at\tUserID\tuser_id\tHTTPCode\thttp_code\tXMLData\txml_data","custom-column-names-with-lit-tags#Custom Column Names with lit Tags":"The simplest way to override column names for specific fields is using the lit struct tag. This is useful when you need to map a few fields to non-standard column names without creating a full naming strategy.\ntype User struct {\n    Id        int    `lit:\"id\"`\n    FirstName string `lit:\"first_name\"`\n    LastName  string `lit:\"surname\"`       // Maps to \"surname\" instead of \"last_name\"\n    Email     string `lit:\"email_address\"` // Maps to \"email_address\" instead of \"email\"\n}","mixing-tagged-and-untagged-fields#Mixing Tagged and Untagged Fields":"You can use lit tags on only some fields. Fields without tags use the default snake_case conversion:\ntype User struct {\n    Id          int                       // Uses default: \"id\"\n    FirstName   string `lit:\"given_name\"` // Uses tag: \"given_name\"\n    LastName    string                    // Uses default: \"last_name\"\n    PhoneNumber string `lit:\"phone\"`      // Uses tag: \"phone\"\n}","when-to-use-lit-tags#When to Use lit Tags":"The lit tag is ideal for:\nMapping to existing database columns with non-standard names\nQuick overrides when you only need to change a few column names\nLegacy database integration where column names don't follow conventions\nThe tag affects:\nINSERT queries: Column names in the generated INSERT statement\nUPDATE queries: Column names in the generated UPDATE statement\nSELECT queries: Mapping database columns back to struct fields","precedence#Precedence":"The lit tag takes precedence over any naming strategy. If a field has a lit tag, that value is always used regardless of the registered naming strategy.\ntype MyNamingStrategy struct{}\nfunc (MyNamingStrategy) GetColumnNameFromStructName(name string) string {\n    return strings.ToUpper(name) // Would return \"FIRSTNAME\"\n}\nfunc (MyNamingStrategy) GetTableNameFromStructName(name string) string {\n    return strings.ToLower(name) + \"s\"\n}\ntype User struct {\n    FirstName string `lit:\"fname\"` // Uses \"fname\", not \"FIRSTNAME\"\n}\nlit.RegisterModelWithNaming[User](lit.PostgreSQL, MyNamingStrategy{})","custom-column-naming-strategy#Custom Column Naming Strategy":"For full control over all column names, implement GetColumnNameFromStructName:\ntype UppercaseColumnsStrategy struct{}\nfunc (UppercaseColumnsStrategy) GetTableNameFromStructName(name string) string {\n    return toSnakeCase(name) + \"s\" // Keep default table naming\n}\nfunc (UppercaseColumnsStrategy) GetColumnNameFromStructName(name string) string {\n    return strings.ToUpper(toSnakeCase(name)) // FIRST_NAME, LAST_NAME, etc.\n}\n// Usage\nlit.RegisterModelWithNaming[User](lit.PostgreSQL, UppercaseColumnsStrategy{})\n// FirstName → FIRST_NAME","table-naming#Table Naming":"","default-table-names#Default Table Names":"Struct names are converted from CamelCase to snake_case and pluralized with \"s\". Consecutive uppercase letters (acronyms) are kept together:\nStruct\tTable\tUser\tusers\tOrderItem\torder_items\tHTTPRequest\thttp_requests\tUserID\tuser_ids\tOAuth2Token\toauth2_tokens","custom-table-naming-strategy#Custom Table Naming Strategy":"To customize how table names are derived, implement GetTableNameFromStructName:\ntype PrefixedTableStrategy struct {\n    Prefix string\n}\nfunc (s PrefixedTableStrategy) GetTableNameFromStructName(name string) string {\n    return s.Prefix + toSnakeCase(name) + \"s\"\n}\nfunc (s PrefixedTableStrategy) GetColumnNameFromStructName(name string) string {\n    return toSnakeCase(name) // Keep default column naming\n}\n// Usage\nlit.RegisterModelWithNaming[User](lit.PostgreSQL, PrefixedTableStrategy{Prefix: \"app_\"})\n// User → app_users","example-singular-table-names-no-pluralization#Example: Singular Table Names (No Pluralization)":"type SingularTableStrategy struct{}\nfunc (SingularTableStrategy) GetTableNameFromStructName(name string) string {\n    return toSnakeCase(name) // No \"s\" suffix: User → user\n}\nfunc (SingularTableStrategy) GetColumnNameFromStructName(name string) string {\n    return toSnakeCase(name)\n}\n// Usage\nlit.RegisterModelWithNaming[User](lit.PostgreSQL, SingularTableStrategy{})\n// User → user (not \"users\")","example-exact-table-name#Example: Exact Table Name":"When you need to map to a specific table name that doesn't follow any convention:\ntype ExactTableStrategy struct {\n    TableName string\n}\nfunc (s ExactTableStrategy) GetTableNameFromStructName(name string) string {\n    return s.TableName // Use exact name provided\n}\nfunc (s ExactTableStrategy) GetColumnNameFromStructName(name string) string {\n    return toSnakeCase(name)\n}\n// Usage - map User struct to \"TBL_USERS\" table\nlit.RegisterModelWithNaming[User](lit.PostgreSQL, ExactTableStrategy{TableName: \"TBL_USERS\"})\n// User → TBL_USERS","example-schema-qualified-table-names#Example: Schema-Qualified Table Names":"type SchemaTableStrategy struct {\n    Schema string\n}\nfunc (s SchemaTableStrategy) GetTableNameFromStructName(name string) string {\n    return s.Schema + \".\" + toSnakeCase(name) + \"s\"\n}\nfunc (s SchemaTableStrategy) GetColumnNameFromStructName(name string) string {\n    return toSnakeCase(name)\n}\n// Usage\nlit.RegisterModelWithNaming[User](lit.PostgreSQL, SchemaTableStrategy{Schema: \"public\"})\n// User → public.users","using-different-strategies-per-model#Using Different Strategies Per Model":"Each model can have its own naming strategy:\n// Default naming for User\nlit.RegisterModel[User](lit.PostgreSQL)\n// User → users\n// Prefixed tables for LegacyCustomer\nlit.RegisterModelWithNaming[LegacyCustomer](lit.PostgreSQL, PrefixedTableStrategy{Prefix: \"legacy_\"})\n// LegacyCustomer → legacy_legacy_customers\n// Singular naming for AuditLog\nlit.RegisterModelWithNaming[AuditLog](lit.PostgreSQL, SingularTableStrategy{})\n// AuditLog → audit_log\n// Exact table name for SpecialModel\nlit.RegisterModelWithNaming[SpecialModel](lit.PostgreSQL, ExactTableStrategy{TableName: \"my_special_table\"})\n// SpecialModel → my_special_table","complete-example-legacy-database-integration#Complete Example: Legacy Database Integration":"When working with an existing database that doesn't follow conventions, combine table and column naming:\ntype LegacyNamingStrategy struct {\n    TableName string\n    Columns   map[string]string\n}\nfunc (s LegacyNamingStrategy) GetTableNameFromStructName(name string) string {\n    return s.TableName\n}\nfunc (s LegacyNamingStrategy) GetColumnNameFromStructName(name string) string {\n    if col, ok := s.Columns[name]; ok {\n        return col\n    }\n    return name // Fallback to exact field name\n}\n// Usage for a legacy table \"TBL_USERS\" with non-standard columns\nlit.RegisterModelWithNaming[User](lit.PostgreSQL, LegacyNamingStrategy{\n    TableName: \"TBL_USERS\",\n    Columns: map[string]string{\n        \"Id\":        \"USER_ID\",\n        \"FirstName\": \"FNAME\",\n        \"LastName\":  \"LNAME\",\n        \"Email\":     \"EMAIL_ADDR\",\n    },\n})\n// User struct maps to:\n// - Table: TBL_USERS\n// - Columns: USER_ID, FNAME, LNAME, EMAIL_ADDR","helper-function#Helper Function":"Most examples use this helper for snake_case conversion:\nfunc toSnakeCase(input string) string {\n\tvar result strings.Builder\n\trunes := []rune(input)\n\tfor i := 0; i < len(runes); i++ {\n\t\tr := runes[i]\n\t\tif unicode.IsUpper(r) {\n\t\t\tif i > 0 {\n\t\t\t\tprevLower := unicode.IsLower(runes[i-1])\n\t\t\t\tnextLower := i+1 < len(runes) && unicode.IsLower(runes[i+1])\n\t\t\t\tprevUpper := unicode.IsUpper(runes[i-1])\n\t\t\t\tif prevLower || (prevUpper && nextLower) {\n\t\t\t\t\tresult.WriteRune('_')\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult.WriteRune(unicode.ToLower(r))\n\t\t} else {\n\t\t\tresult.WriteRune(r)\n\t\t}\n\t}\n\treturn result.String()\n}"}},"/guides/uuid-support":{"title":"UUID Support","data":{"":"lit supports UUID primary keys through dedicated insert functions.","when-to-use-uuids#When to Use UUIDs":"UUIDs are useful when you need:\nGlobally unique identifiers across systems\nIDs that don't reveal sequence information\nClient-generated IDs before server insertion\nDistributed systems without ID coordination","model-definition#Model Definition":"Define your model with a string ID:\ntype Session struct {\n    Id        string\n    UserId    int\n    Token     string\n    ExpiresAt time.Time\n}\nWhen registering, lit detects that Id is not an integer and sets HasIntId = false. This changes how INSERT queries are generated.","insertuuid#InsertUuid":"Use this when you want lit to generate the UUID:\nfunc InsertUuid[T any](ex Executor, t *T) (string, error)","example#Example":"type Session struct {\n    Id        string\n    UserId    int\n    Token     string\n    ExpiresAt time.Time\n}\nlit.RegisterModel[Session](lit.PostgreSQL)\nsession := Session{\n    UserId:    123,\n    Token:     \"abc123\",\n    ExpiresAt: time.Now().Add(24 * time.Hour),\n}\n// lit generates UUID and sets it on the struct\nuuid, err := lit.InsertUuid(db, &session)\nif err != nil {\n    return err\n}\nfmt.Printf(\"Created session: %s\\n\", uuid)\nfmt.Printf(\"session.Id is also set: %s\\n\", session.Id)\n// Both print the same UUID","how-it-works#How It Works":"Generates a new UUID using github.com/google/uuid\nSets the UUID on the struct's Id field\nExecutes the INSERT with all fields including the ID\nReturns the generated UUID","insertexistinguuid#InsertExistingUuid":"Use this when you already have a UUID:\nfunc InsertExistingUuid[T any](ex Executor, t *T) error","example-1#Example":"session := Session{\n    Id:        \"550e8400-e29b-41d4-a716-446655440000\", // Pre-generated or received from client\n    UserId:    123,\n    Token:     \"abc123\",\n    ExpiresAt: time.Now().Add(24 * time.Hour),\n}\nerr := lit.InsertExistingUuid(db, &session)\nif err != nil {\n    return err\n}","use-cases#Use Cases":"Receiving UUIDs from clients (e.g., offline-first apps)\nMigrating data with existing IDs\nTesting with deterministic IDs\nDistributed ID generation (e.g., from a separate service)","database-schema#Database Schema":"Ensure your database table can store UUIDs:","postgresql#PostgreSQL":"CREATE TABLE sessions (\n    id UUID PRIMARY KEY,\n    user_id INTEGER NOT NULL,\n    token VARCHAR(255) NOT NULL,\n    expires_at TIMESTAMP NOT NULL\n);\nOr with text storage:\nCREATE TABLE sessions (\n    id VARCHAR(36) PRIMARY KEY,\n    user_id INTEGER NOT NULL,\n    token VARCHAR(255) NOT NULL,\n    expires_at TIMESTAMP NOT NULL\n);","mysql#MySQL":"CREATE TABLE sessions (\n    id VARCHAR(36) PRIMARY KEY,\n    user_id INT NOT NULL,\n    token VARCHAR(255) NOT NULL,\n    expires_at DATETIME NOT NULL\n);\nOr with BINARY storage for efficiency:\nCREATE TABLE sessions (\n    id BINARY(16) PRIMARY KEY,\n    user_id INT NOT NULL,\n    token VARCHAR(255) NOT NULL,\n    expires_at DATETIME NOT NULL\n);","complete-example#Complete Example":"package main\nimport (\n    \"database/sql\"\n    \"time\"\n    \"github.com/tracewayapp/go-lightning/lit\"\n    _ \"github.com/lib/pq\"\n)\ntype ApiKey struct {\n    Id        string\n    UserId    int\n    Name      string\n    Key       string\n    CreatedAt time.Time\n}\nfunc init() {\n    lit.RegisterModel[ApiKey](lit.PostgreSQL)\n}\ntype ApiKeyRepository struct{}\nfunc (r *ApiKeyRepository) Create(ex lit.Executor, userId int, name string, key string) (*ApiKey, error) {\n    apiKey := ApiKey{\n        UserId:    userId,\n        Name:      name,\n        Key:       key,\n        CreatedAt: time.Now(),\n    }\n    _, err := lit.InsertUuid(ex, &apiKey)\n    if err != nil {\n        return nil, err\n    }\n    return &apiKey, nil\n}\nfunc (r *ApiKeyRepository) FindById(ex lit.Executor, id string) (*ApiKey, error) {\n    return lit.SelectSingle[ApiKey](ex,\n        \"SELECT id, user_id, name, key, created_at FROM api_keys WHERE id = $1\", id)\n}\nfunc (r *ApiKeyRepository) FindByUserId(ex lit.Executor, userId int) ([]*ApiKey, error) {\n    return lit.Select[ApiKey](ex,\n        \"SELECT id, user_id, name, key, created_at FROM api_keys WHERE user_id = $1\", userId)\n}"}},"/comparison":{"title":"Comparison","data":{"":"How does lit compare to other Go database libraries?","vs-gorm#vs GORM":"GORM is a full-featured ORM with associations, hooks, migrations, and more.\nAspect\tGORM\tlit\tQuery Builder\tYes, chainable API\tNo, write SQL\tRelationships\tFull support (belongs_to, has_many, etc.)\tNone\tMigrations\tBuilt-in auto-migrate\tNone\tHooks\tBefore/After callbacks\tNone\tQuery Caching\tNo\tYes, at registration\tLearning Curve\tModerate to steep\tMinimal\tDependencies\tHeavy\tMinimal\t\nChoose lit if: You want simplicity, full SQL control, and minimal overhead.Choose GORM if: You need relationship management, auto-migrations, or an ActiveRecord-style API.","code-comparison#Code Comparison":"// GORM\ndb.Where(\"email = ?\", email).First(&user)\ndb.Create(&user)\ndb.Save(&user)\n// lit\nlit.SelectSingle[User](db, \"SELECT id, name, email FROM users WHERE email = $1\", email)\nlit.Insert(db, &user)\nlit.Update(db, &user, \"id = $1\", user.Id)","vs-sqlx#vs sqlx":"sqlx extends database/sql with struct scanning and named parameters.\nAspect\tsqlx\tlit\tStruct Scanning\tYes, via tags\tYes, via registration\tNamed Parameters\tYes\tNo\tINSERT Generation\tNo\tYes\tUPDATE Generation\tNo\tYes\tReflection\tEvery query\tOnce at registration\tQuery Caching\tNo\tYes\t\nChoose lit if: You want auto-generated INSERT/UPDATE with cached queries.Choose sqlx if: You need named parameters or prefer struct tags over registration.","code-comparison-1#Code Comparison":"// sqlx - requires writing INSERT manually\ntype User struct {\n    Id    int    `db:\"id\"`\n    Name  string `db:\"name\"`\n    Email string `db:\"email\"`\n}\ndb.Get(&user, \"SELECT * FROM users WHERE id = $1\", id)\ndb.Exec(\"INSERT INTO users (name, email) VALUES ($1, $2)\", user.Name, user.Email)\n// lit - INSERT is auto-generated\ntype User struct {\n    Id    int\n    Name  string\n    Email string\n}\nlit.RegisterModel[User](lit.PostgreSQL)\nlit.SelectSingle[User](db, \"SELECT id, name, email FROM users WHERE id = $1\", id)\nlit.Insert(db, &user) // Query pre-generated","vs-sqlc#vs sqlc":"sqlc generates type-safe Go code from SQL queries.\nAspect\tsqlc\tlit\tCode Generation\tYes, required\tNo\tBuild Step\tYes\tNo\tType Safety\tCompile-time\tRuntime\tQuery Changes\tRegenerate code\tUpdate SQL string\tIDE Support\tFull (generated types)\tStandard Go\tRuntime Flexibility\tNone\tFull\t\nChoose lit if: You want runtime flexibility without a build step.Choose sqlc if: You want compile-time type safety and don't mind code generation.","workflow-comparison#Workflow Comparison":"# sqlc workflow\n1. Write SQL in .sql files\n2. Run `sqlc generate`\n3. Use generated Go functions\n4. Repeat on query changes\n# lit workflow\n1. Define Go struct\n2. Register model\n3. Write SQL in Go code\n4. No regeneration needed","vs-ent#vs ent":"ent is a code-generation based ORM with a graph-based API.\nAspect\tent\tlit\tCode Generation\tHeavy (entire data layer)\tNone\tSchema Definition\tGo code with DSL\tPlain Go structs\tRelationships\tFirst-class support\tNone\tGraph Traversal\tYes\tNo\tMigrations\tAuto-generated\tNone\tLearning Curve\tSteep\tMinimal\t\nChoose lit if: You want simplicity and no code generation.Choose ent if: You need graph-style queries and relationships.","schema-comparison#Schema Comparison":"// ent - schema definition DSL\nfunc (User) Fields() []ent.Field {\n    return []ent.Field{\n        field.String(\"name\"),\n        field.String(\"email\").Unique(),\n    }\n}\nfunc (User) Edges() []ent.Edge {\n    return []ent.Edge{\n        edge.To(\"posts\", Post.Type),\n    }\n}\n// lit - plain struct\ntype User struct {\n    Id    int\n    Name  string\n    Email string\n}","summary-table#Summary Table":"Feature\tlit\tGORM\tsqlx\tsqlc\tent\tCode Generation\tNone\tNone\tNone\tRequired\tRequired\tBuild Step\tNo\tNo\tNo\tYes\tYes\tQuery Caching\tYes\tNo\tNo\tN/A\tNo\tINSERT/UPDATE Gen\tYes\tYes\tNo\tYes\tYes\tRelationships\tNo\tYes\tNo\tNo\tYes\tMigrations\tNo\tYes\tNo\tNo\tYes\tDependencies\tMinimal\tHeavy\tLight\tNone\tHeavy\tLearning Curve\tLow\tMedium\tLow\tMedium\tHigh\tSQL Control\tFull\tPartial\tFull\tFull\tPartial","when-to-choose-lit#When to Choose lit":"lit is ideal when you:\nWant to write your own SQL\nDon't need relationship mapping\nValue simplicity over features\nWant minimal dependencies\nNeed fast startup and runtime performance\nPrefer no code generation step\nAre building microservices or APIs with straightforward data access"}},"/core-concepts/mutations":{"title":"Mutations","data":{"":"lit provides functions for creating, updating, and deleting data.","insert#Insert":"Insert a new record and get the generated ID:\nfunc Insert[T any](ex Executor, t *T) (int, error)","example#Example":"user := User{\n    FirstName: \"John\",\n    LastName:  \"Doe\",\n    Email:     \"john@example.com\",\n}\nid, err := lit.Insert(db, &user)\nif err != nil {\n    return err\n}\nfmt.Printf(\"Created user with ID: %d\\n\", id)\nThe INSERT query is pre-generated during registration, so this operation has minimal overhead.","insert-with-uuid#Insert with UUID":"For models with string/UUID IDs, use one of these functions:","insertuuid#InsertUuid":"Generates a new UUID automatically:\nfunc InsertUuid[T any](ex Executor, t *T) (string, error)\ntype Session struct {\n    Id        string\n    UserId    int\n    ExpiresAt time.Time\n}\nlit.RegisterModel[Session](lit.PostgreSQL)\nsession := Session{\n    UserId:    123,\n    ExpiresAt: time.Now().Add(24 * time.Hour),\n}\nuuid, err := lit.InsertUuid(db, &session)\n// uuid = \"550e8400-e29b-41d4-a716-446655440000\"\n// session.Id is also set to this value","insertexistinguuid#InsertExistingUuid":"Use when you already have a UUID:\nfunc InsertExistingUuid[T any](ex Executor, t *T) error\nsession := Session{\n    Id:        \"my-existing-uuid\",\n    UserId:    123,\n    ExpiresAt: time.Now().Add(24 * time.Hour),\n}\nerr := lit.InsertExistingUuid(db, &session)\nSee UUID Support for more details.","update#Update":"Update a record with a WHERE clause:\nfunc Update[T any](ex Executor, t *T, where string, args ...any) error\nImportant: The where parameter is required and cannot be empty. This prevents accidental updates to all rows.","example-1#Example":"user.FirstName = \"Jane\"\nuser.Email = \"jane@example.com\"\nerr := lit.Update(db, &user, \"id = $1\", user.Id)\nThe UPDATE query base is pre-generated. The WHERE clause is appended at runtime.","postgresql-placeholder-handling#PostgreSQL Placeholder Handling":"For PostgreSQL, placeholders in your WHERE clause are automatically renumbered:\n// Your code\nlit.Update(db, &user, \"id = $1 AND active = $2\", user.Id, true)\n// Executed query (if User has 4 fields):\n// UPDATE users SET id = $1, first_name = $2, last_name = $3, email = $4 WHERE id = $5 AND active = $6","updatenamed#UpdateNamed":"Update with portable :name placeholders in the WHERE clause:\nfunc UpdateNamed[T any](ex Executor, t *T, where string, params map[string]any) error\nUpdateNamed infers the driver from the model's registration and delegates to Update, which handles PostgreSQL placeholder renumbering internally.\nuser.Email = \"jane@example.com\"\nerr := lit.UpdateNamed(db, &user, \"id = :id\", lit.P{\"id\": user.Id})\nMissing parameters return an error without executing the query:\nerr := lit.UpdateNamed(db, &user, \"id = :id AND email = :email\",\n    lit.P{\"id\": 1})\n// Error: missing parameter: email","delete#Delete":"Delete uses manual SQL for full control:\nfunc Delete(ex Executor, query string, args ...any) error","example-2#Example":"// Delete single\nerr := lit.Delete(db, \"DELETE FROM users WHERE id = $1\", userId)\n// Delete multiple\nerr := lit.Delete(db, \"DELETE FROM users WHERE last_login < $1\", cutoffDate)\n// Delete with IN clause\nids := []int{1, 2, 3}\nerr := lit.Delete(db,\n    \"DELETE FROM users WHERE id IN (\"+lit.JoinForIn(ids)+\")\")","deletenamed#DeleteNamed":"Delete with portable :name placeholders:\nfunc DeleteNamed(driver Driver, ex Executor, query string, params map[string]any) error\nDeleteNamed takes an explicit driver parameter because Delete is non-generic (there is no model type to infer the driver from).\nerr := lit.DeleteNamed(lit.PostgreSQL, db,\n    \"DELETE FROM users WHERE id = :id\",\n    lit.P{\"id\": 1})\nMissing parameters return an error without executing the query:\nerr := lit.DeleteNamed(lit.PostgreSQL, db,\n    \"DELETE FROM users WHERE id = :id AND email = :email\",\n    lit.P{\"id\": 1})\n// Error: missing parameter: email","in-clause-helpers#IN Clause Helpers":"lit provides helpers for building IN clauses:","joinforin#JoinForIn":"For integer slices:\nfunc JoinForIn(ids []int) string\nids := []int{1, 2, 3, 4, 5}\nquery := \"SELECT * FROM users WHERE id IN (\" + lit.JoinForIn(ids) + \")\"\n// Result: SELECT * FROM users WHERE id IN (1,2,3,4,5)","joinstringforin#JoinStringForIn":"For parameterized IN clauses with strings:\nfunc JoinStringForIn[T any](offset int, params []string) string\nemails := []string{\"a@test.com\", \"b@test.com\"}\n// PostgreSQL (offset=0)\nquery := \"SELECT * FROM users WHERE email IN (\" + lit.JoinStringForIn[User](0, emails) + \")\"\n// Result: SELECT * FROM users WHERE email IN ($1,$2)\n// MySQL\nquery := \"SELECT * FROM users WHERE email IN (\" + lit.JoinStringForIn[User](0, emails) + \")\"\n// Result: SELECT * FROM users WHERE email IN (?,?)","joinstringforinwithdriver#JoinStringForInWithDriver":"When you don't have a registered model:\nfunc JoinStringForInWithDriver(driver Driver, offset int, count int) string\nplaceholders := lit.JoinStringForInWithDriver(lit.PostgreSQL, 0, 3)\n// Result: $1,$2,$3","native-operations#Native Operations":"For cases where auto-generated queries don't fit:","insertnative#InsertNative":"func InsertNative(ex Executor, query string, args ...any) (int, error)\nid, err := lit.InsertNative(db,\n    \"INSERT INTO audit_log (action, timestamp) VALUES ($1, $2) RETURNING id\",\n    \"user_login\", time.Now())","updatenative#UpdateNative":"func UpdateNative(ex Executor, query string, args ...any) error\nerr := lit.UpdateNative(db,\n    \"UPDATE counters SET value = value + 1 WHERE name = $1\",\n    \"page_views\")"}},"/core-concepts/registration":{"title":"Registration","data":{"":"Registration is the foundation of lit's performance. By registering models at startup, all reflection and query generation happens once, not on every database operation.","why-registration-exists#Why Registration Exists":"Traditional ORMs use reflection on every query to map struct fields to database columns. This adds overhead to every operation. lit takes a different approach:\nRegister once at application startup\nUse cached data for all subsequent operations\nMinimal reflection overhead during queries","basic-registration#Basic Registration":"import \"github.com/tracewayapp/go-lightning/lit\"\ntype User struct {\n    Id        int\n    FirstName string\n    LastName  string\n    Email     string\n}\nfunc init() {\n    lit.RegisterModel[User](lit.PostgreSQL)\n}","driver-registration#Driver Registration":"You can register default driver globally. This driver will be used for all models registered without specifying a driver.\nlit.RegisterDriver(lit.PostgreSQL) // or lit.MySQL\nlit.RegisterModel[User]() // uses PostgreSQL driver\nIf for any reason you need to register a model with a different driver than the default, you can still specify it explicitly:\nlit.RegisterDriver(lit.PostgreSQL)\nlit.RegisterModel[User](lit.MySQL) // uses MySQL driver","what-gets-cached#What Gets Cached":"When you call RegisterModel, lit creates a FieldMap containing:\nField\tDescription\tColumnsMap\tMaps column names to field positions\tColumnKeys\tOrdered list of column names\tHasIntId\tWhether id field is an integer (for auto-increment)\tInsertQuery\tPre-built INSERT statement\tUpdateQuery\tPre-built UPDATE statement (without WHERE clause)\tInsertColumns\tColumns used in INSERT (excludes auto-increment id)\tDriver\tDatabase driver (PostgreSQL or MySQL)","default-naming-convention#Default Naming Convention":"lit converts Go's CamelCase to SQL's snake_case:\nGo Field\tSQL Column\tId\tid\tFirstName\tfirst_name\tLastName\tlast_name\tCreatedAt\tcreated_at\tUserID\tuser_i_d\t\nTable names are derived from struct names with an s suffix:\nUser → users\nProduct → products","id-detection#ID Detection":"lit automatically detects if your id field is an integer:\n// Integer ID - uses DEFAULT in INSERT, RETURNING id (PostgreSQL) or LastInsertId (MySQL)\ntype User struct {\n    Id   int    // HasIntId = true\n    Name string\n}\n// String/UUID ID - includes id in INSERT values\ntype Session struct {\n    Id   string  // HasIntId = false\n    Data string\n}","custom-naming-strategy#Custom Naming Strategy":"For different naming conventions, use RegisterModelWithNaming:\ntype MyNamingStrategy struct{}\nfunc (MyNamingStrategy) GetTableNameFromStructName(name string) string {\n    return \"tbl_\" + strings.ToLower(name)\n}\nfunc (MyNamingStrategy) GetColumnNameFromStructName(name string) string {\n    return strings.ToLower(name)\n}\nfunc init() {\n    lit.RegisterModelWithNaming[User](lit.PostgreSQL, MyNamingStrategy{})\n}\nSee Naming Strategies for more details.","generated-queries-example#Generated Queries Example":"For a registered User struct with PostgreSQL:INSERT Query:\nINSERT INTO users (id,first_name,last_name,email) VALUES (DEFAULT,$1,$2,$3) RETURNING id\nUPDATE Query (base):\nUPDATE users SET id = $1,first_name = $2,last_name = $3,email = $4 WHERE\nThe WHERE clause is appended at runtime when you call Update()."}},"/guides/projections":{"title":"Projections & DTOs","data":{"":"lit can map query results to any registered struct, not just your main models. This enables DTOs (Data Transfer Objects) for partial selects, JOINs, and aggregations.","why-use-projections#Why Use Projections?":"Performance: Select only the columns you need\nJOINs: Combine data from multiple tables into one struct\nAggregations: Map COUNT, SUM, AVG results to structs\nAPI Responses: Shape data for specific endpoints\nSecurity: Exclude sensitive fields from query results","basic-projection#Basic Projection":"Select a subset of columns:\n// Full model\ntype User struct {\n    Id           int\n    FirstName    string\n    LastName     string\n    Email        string\n    PasswordHash string\n    CreatedAt    time.Time\n    UpdatedAt    time.Time\n}\n// DTO with only public fields\ntype UserPublic struct {\n    Id        int\n    FirstName string\n    LastName  string\n    Email     string\n}\nfunc init() {\n    lit.RegisterModel[User](lit.PostgreSQL)\n    lit.RegisterModel[UserPublic](lit.PostgreSQL)\n}\n// Use the projection\nusers, err := lit.Select[UserPublic](db,\n    \"SELECT id, first_name, last_name, email FROM users\")\n// Returns []*UserPublic without password_hash, created_at, updated_at","join-projections#JOIN Projections":"Combine data from multiple tables:\ntype OrderWithCustomer struct {\n    OrderId      int\n    OrderDate    time.Time\n    Total        float64\n    CustomerName string\n    CustomerEmail string\n}\nlit.RegisterModel[OrderWithCustomer](lit.PostgreSQL)\nresults, err := lit.Select[OrderWithCustomer](db, `\n    SELECT\n        o.id as order_id,\n        o.order_date,\n        o.total,\n        c.name as customer_name,\n        c.email as customer_email\n    FROM orders o\n    JOIN customers c ON c.id = o.customer_id\n    WHERE o.order_date > $1\n`, startDate)","important-column-aliases#Important: Column Aliases":"Use SQL aliases (AS) to match your struct field names:\no.id → order_id (matches OrderId field)\nc.name → customer_name (matches CustomerName field)","aggregation-projections#Aggregation Projections":"type CategoryStats struct {\n    CategoryId   int\n    CategoryName string\n    ProductCount int\n    AvgPrice     float64\n    TotalRevenue float64\n}\nlit.RegisterModel[CategoryStats](lit.PostgreSQL)\nstats, err := lit.Select[CategoryStats](db, `\n    SELECT\n        c.id as category_id,\n        c.name as category_name,\n        COUNT(p.id) as product_count,\n        AVG(p.price) as avg_price,\n        SUM(p.price * p.units_sold) as total_revenue\n    FROM categories c\n    LEFT JOIN products p ON p.category_id = c.id\n    GROUP BY c.id, c.name\n    ORDER BY total_revenue DESC\n`)","nested-data-with-multiple-queries#Nested Data with Multiple Queries":"For complex nested structures, use multiple queries:\ntype UserWithOrders struct {\n    User   *User\n    Orders []*Order\n}\nfunc GetUserWithOrders(db *sql.DB, userId int) (*UserWithOrders, error) {\n    user, err := lit.SelectSingle[User](db,\n        \"SELECT id, first_name, last_name, email FROM users WHERE id = $1\", userId)\n    if err != nil {\n        return nil, err\n    }\n    if user == nil {\n        return nil, nil\n    }\n    orders, err := lit.Select[Order](db,\n        \"SELECT id, user_id, total, status, created_at FROM orders WHERE user_id = $1\", userId)\n    if err != nil {\n        return nil, err\n    }\n    return &UserWithOrders{User: user, Orders: orders}, nil\n}","pagination-dto#Pagination DTO":"type PaginatedUsers struct {\n    Users      []*UserPublic\n    TotalCount int\n    Page       int\n    PageSize   int\n}\ntype CountResult struct {\n    Count int\n}\nlit.RegisterModel[CountResult](lit.PostgreSQL)\nfunc GetPaginatedUsers(db *sql.DB, page, pageSize int) (*PaginatedUsers, error) {\n    offset := (page - 1) * pageSize\n    // Get total count\n    countResult, err := lit.SelectSingle[CountResult](db,\n        \"SELECT COUNT(*) as count FROM users\")\n    if err != nil {\n        return nil, err\n    }\n    // Get page of users\n    users, err := lit.Select[UserPublic](db,\n        \"SELECT id, first_name, last_name, email FROM users ORDER BY id LIMIT $1 OFFSET $2\",\n        pageSize, offset)\n    if err != nil {\n        return nil, err\n    }\n    return &PaginatedUsers{\n        Users:      users,\n        TotalCount: countResult.Count,\n        Page:       page,\n        PageSize:   pageSize,\n    }, nil\n}","search-results#Search Results":"type UserSearchResult struct {\n    Id        int\n    FirstName string\n    LastName  string\n    Email     string\n    MatchType string // \"email\" or \"name\"\n}\nlit.RegisterModel[UserSearchResult](lit.PostgreSQL)\nfunc SearchUsers(db *sql.DB, query string) ([]*UserSearchResult, error) {\n    searchPattern := \"%\" + query + \"%\"\n    return lit.Select[UserSearchResult](db, `\n        SELECT\n            id,\n            first_name,\n            last_name,\n            email,\n            CASE\n                WHEN email ILIKE $1 THEN 'email'\n                ELSE 'name'\n            END as match_type\n        FROM users\n        WHERE email ILIKE $1\n           OR first_name ILIKE $1\n           OR last_name ILIKE $1\n        ORDER BY\n            CASE WHEN email ILIKE $1 THEN 0 ELSE 1 END,\n            first_name\n    `, searchPattern)\n}","tips#Tips":"Register all DTOs: Each struct you use with Select or SelectSingle must be registered\nMatch column names: SQL column names (or aliases) must match your struct field names after snake_case conversion\nColumn validation: lit validates columns at runtime and returns clear errors for mismatches\nReuse DTOs: Create a dto package for shared projection types\nKeep it simple: If a projection is only used once, consider if it's worth the extra type"}}}
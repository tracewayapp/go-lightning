{"/api-reference/core/helpers":{"title":"Helper Functions","data":{"":"Utility functions for validation and query building.","validatecolumns#ValidateColumns":"Validates that all column names exist in a registered struct.","signature#Signature":"func ValidateColumns[T any](columns []string, fieldMap *FieldMap) error","description#Description":"Used internally by SelectGeneric to ensure query columns match struct fields.","getpointersforcolumns#GetPointersForColumns":"Creates pointers to struct fields in the order needed for scanning.","signature-1#Signature":"func GetPointersForColumns[T any](columns []string, fieldMap *FieldMap, t *T) *[]interface{}","description-1#Description":"Internal function used by generic operations for efficient row scanning.","joinforin#JoinForIn":"Builds comma-separated string for integer IN clauses.","signature-2#Signature":"func JoinForIn(ids []int) string","example#Example":"ids := []int{1, 2, 3}\nquery := fmt.Sprintf(\"SELECT * FROM users WHERE id IN (%s)\", lpg.JoinForIn(ids))\n// query: \"SELECT * FROM users WHERE id IN (1,2,3)\"\nSee complete documentation for parameter handling helpers in database-specific modules."}},"/api-reference/core/generic-operations":{"title":"Generic Operations","data":{"":"Type-safe database operations with automatic struct-to-row mapping.All generic operations require prior type registration with Register[T]().","selectgeneric#SelectGeneric":"Execute a SELECT query and return multiple rows as a slice of structs.","signature#Signature":"func SelectGeneric[T any](tx *sql.Tx, query string, args ...any) ([]*T, error)","parameters#Parameters":"T - Struct type (must be registered)\ntx - Database transaction\nquery - SQL SELECT query\nargs - Query parameters (variadic)","returns#Returns":"[]*T - Slice of pointers to struct instances\nerror - Error if query fails or columns don't match struct","example#Example":"users, err := lpg.SelectGeneric[User](tx, \"SELECT * FROM users WHERE age > $1\", 25)\nif err != nil {\n    return err\n}\nfor _, user := range users {\n    fmt.Printf(\"%s %s\\n\", user.FirstName, user.LastName)\n}","behavior#Behavior":"Returns empty slice (not nil) when no rows found\nValidates all returned columns exist in struct\nAutomatically maps columns to struct fields","selectgenericsingle#SelectGenericSingle":"Execute a SELECT query and return the first row or nil.","signature-1#Signature":"func SelectGenericSingle[T any](tx *sql.Tx, query string, args ...any) (*T, error)","returns-1#Returns":"*T - Pointer to struct instance, or nil if no rows\nerror - Error if query fails","example-1#Example":"user, err := lpg.SelectGenericSingle[User](tx, \"SELECT * FROM users WHERE id = $1\", userId)\nif err != nil {\n    return err\n}\nif user == nil {\n    return errors.New(\"user not found\")\n}\nfmt.Println(user.Name)","behavior-1#Behavior":"Returns nil, nil (not error) when no rows found\nReturns first row if multiple rows match","insertgeneric#InsertGeneric":"Insert a struct and return the auto-generated integer ID.","signature-2#Signature":"func InsertGeneric[T any](tx *sql.Tx, t *T) (int, error)","parameters-1#Parameters":"t - Pointer to struct instance","returns-2#Returns":"int - Auto-generated ID from database\nerror - Error if insert fails","requirements#Requirements":"Struct must have integer Id field\nDatabase column must be auto-increment","example-2#Example":"user := &User{\n    FirstName: \"John\",\n    LastName:  \"Doe\",\n    Email:     \"john@example.com\",\n}\nid, err := lpg.InsertGeneric(tx, user)\nif err != nil {\n    return err\n}\nfmt.Printf(\"Inserted user with ID: %d\\n\", id)","insertgenericuuid#InsertGenericUuid":"Insert a struct with auto-generated UUID for string Id field.","signature-3#Signature":"func InsertGenericUuid[T any](tx *sql.Tx, t *T) (string, error)","returns-3#Returns":"string - Generated UUID\nerror - Error if insert fails","example-3#Example":"entity := &Entity{Name: \"My Entity\"}\nuuid, err := lpg.InsertGenericUuid(tx, entity)\n// entity.Id is now set to the generated UUID","insertgenericexistinguuid#InsertGenericExistingUuid":"Insert a struct with pre-existing UUID in the Id field.","signature-4#Signature":"func InsertGenericExistingUuid[T any](tx *sql.Tx, t *T) error","example-4#Example":"entity := &Entity{\n    Id:   uuid.New().String(),\n    Name: \"My Entity\",\n}\nerr := lpg.InsertGenericExistingUuid(tx, entity)","updategeneric#UpdateGeneric":"Update all fields of a struct based on a WHERE clause.","signature-5#Signature":"func UpdateGeneric[T any](tx *sql.Tx, t *T, where string, args ...any) error","parameters-2#Parameters":"t - Pointer to struct with updated values\nwhere - WHERE clause (required, non-empty)\nargs - WHERE clause parameters","important#Important":"Updates ALL fields in struct\nWHERE clause is required\nPostgreSQL: $N placeholders are automatically renumbered","example-5#Example":"user.FirstName = \"Jane\"\nerr := lpg.UpdateGeneric(tx, user, \"id = $1\", user.Id)\nSee API Reference for complete documentation."}},"/api-reference/core/registration":{"title":"Registration Functions","data":{"":"Functions for registering struct types with go-lightning.","register#Register":"Registers a struct type for use with generic database operations.","signature#Signature":"func Register[T any](namingStrategy DbNamingStrategy, queryGenerator InsertUpdateQueryGenerator)","parameters#Parameters":"T - The struct type to register (type parameter)\nnamingStrategy - Implementation of DbNamingStrategy interface\nqueryGenerator - Implementation of InsertUpdateQueryGenerator interface","description#Description":"Register[T]() performs one-time reflection on a struct type to build metadata (FieldMap) that enables fast, type-safe database operations.What happens:\nReflects on struct T to extract field names and types\nApplies naming strategy to convert Go names → database names\nDetects integer Id field for auto-increment handling\nGenerates INSERT and UPDATE query templates\nStores FieldMap in global registry","example#Example":"import golightning \"github.com/tracewayapp/go-lightning\"\nimport \"github.com/tracewayapp/go-lightning/lpg\"\ntype User struct {\n    Id        int\n    FirstName string\n    LastName  string\n    Email     string\n}\nfunc init() {\n    // Register with custom naming and PostgreSQL query generator\n    golightning.Register[User](\n        golightning.DefaultDbNamingStrategy{},\n        lpg.PgInsertUpdateQueryGenerator{},\n    )\n}","database-specific-shortcuts#Database-Specific Shortcuts":"","postgresql#PostgreSQL":"import \"github.com/tracewayapp/go-lightning/lpg\"\nfunc init() {\n    lpg.Register[User]()  // Uses DefaultDbNamingStrategy + PgInsertUpdateQueryGenerator\n}","mysql#MySQL":"import \"github.com/tracewayapp/go-lightning/lmy\"\nfunc init() {\n    lmy.Register[User]()  // Uses DefaultDbNamingStrategy + MySqlInsertUpdateQueryGenerator\n}","when-to-call#When to Call":"Recommended: In init() function\nfunc init() {\n    lpg.Register[User]()\n}\nWhy init()?\nRuns automatically when package is imported\nExecutes exactly once\nHappens before main() starts\nThread-safe","errors#Errors":"If you use a type without registering it first:\n// ❌ Never registered\ntype User struct { /* ... */ }\nfunc main() {\n    id, err := lpg.InsertGeneric(tx, &User{})\n    // Panic: Non registered model User used. Please call `var _ = Register[User]()` after you define User\n}\nSolution: Always register in init():\nfunc init() {\n    lpg.Register[User]()\n}","see-also#See Also":"Registration Guide - Comprehensive registration guide\nGetFieldMap - Retrieve registration metadata","getfieldmap#GetFieldMap":"Retrieves the FieldMap for a registered struct type.","signature-1#Signature":"func GetFieldMap(t reflect.Type) (*FieldMap, error)","parameters-1#Parameters":"t - The reflect.Type of the registered struct","returns#Returns":"*FieldMap - Pointer to the registered metadata\nerror - Error if type was never registered","description-1#Description":"Returns the pre-computed FieldMap containing column mappings, query templates, and other metadata for a registered type.","example-1#Example":"import (\n    \"reflect\"\n    \"log\"\n    golightning \"github.com/tracewayapp/go-lightning\"\n)\ntype User struct {\n    Id   int\n    Name string\n}\nfunc init() {\n    golightning.Register[User](\n        golightning.DefaultDbNamingStrategy{},\n        lpg.PgInsertUpdateQueryGenerator{},\n    )\n}\nfunc main() {\n    userType := reflect.TypeOf(User{})\n    fieldMap, err := golightning.GetFieldMap(userType)\n    if err != nil {\n        log.Fatal(\"User type not registered:\", err)\n    }\n    fmt.Println(\"Columns:\", fieldMap.ColumnKeys)\n    fmt.Println(\"INSERT Query:\", fieldMap.InsertQuery)\n    fmt.Println(\"UPDATE Query:\", fieldMap.UpdateQuery)\n}\nOutput:\nColumns: [id name]\nINSERT Query: INSERT INTO users (name) VALUES ($1) RETURNING id\nUPDATE Query: UPDATE users SET id = $1, name = $2 WHERE","error-handling#Error Handling":"fieldMap, err := golightning.GetFieldMap(reflect.TypeOf(UnregisteredType{}))\nif err != nil {\n    // Error: \"Non registered model UnregisteredType used...\"\n    log.Fatal(err)\n}","use-cases#Use Cases":"Debugging - Inspect generated queries\nTesting - Verify registration configuration\nAdvanced Usage - Custom operations needing field metadata","see-also-1#See Also":"FieldMap Structure\nRegistration Guide"}},"/api-reference/mysql/crud-operations":{"title":"MySQL CRUD Operations","data":{"":"Complete reference for MySQL-specific CRUD operations.All operations are in the lmy package and support MySQL-specific features.","see-core-documentation#See Core Documentation":"Most operations delegate directly to core implementations:\nGeneric Operations - Core generic functions\nManual Operations - Core manual functions","mysql-specific-differences#MySQL-Specific Differences":"","parameter-placeholders#Parameter Placeholders":"All parameters use ?:\nuser, err := lmy.SelectGenericSingle[User](tx,\n    \"SELECT * FROM users WHERE id = ?\", userId)","insertgeneric#InsertGeneric":"Uses NULL for AUTO_INCREMENT fields:\nid, err := lmy.InsertGeneric(tx, &user)\n// Executes: INSERT INTO users (id, name) VALUES (NULL, ?)\n// Then uses LastInsertId() to get generated ID","joinstringforin#JoinStringForIn":"Generates ? placeholders (offset parameter ignored):\nparams := []string{\"a\", \"b\", \"c\"}\nplaceholders := lmy.JoinStringForIn(0, params)\n// Returns: \"?,?,?\"\nSee MySQL Guide for detailed examples."}},"/api-reference/core/manual-operations":{"title":"Manual Operations","data":{"":"Database operations with custom row mapping functions. No type registration required.","selectmultiple#SelectMultiple":"Execute SELECT with custom mapping function, returns multiple rows.","signature#Signature":"func SelectMultiple[T any](tx *sql.Tx, mapLine func(*sql.Rows, *T) error, query string, args ...any) ([]*T, error)","parameters#Parameters":"mapLine - Function to map a row to a struct\nquery - SQL SELECT query\nargs - Query parameters","example#Example":"func mapUser(rows *sql.Rows, user *User) error {\n    return rows.Scan(&user.Id, &user.Name, &user.Email)\n}\nusers, err := lpg.SelectMultiple[User](tx, mapUser,\n    \"SELECT id, name, email FROM users\")","selectsingle#SelectSingle":"Execute SELECT with custom mapping, returns first row or nil.","signature-1#Signature":"func SelectSingle[T any](tx *sql.Tx, mapLine func(*sql.Rows, *T) error, query string, args ...any) (*T, error)","insert#Insert":"Execute INSERT query and return last insert ID.","signature-2#Signature":"func Insert(tx *sql.Tx, query string, args ...any) (int, error)","update#Update":"Execute UPDATE query.","signature-3#Signature":"func Update(tx *sql.Tx, query string, args ...any) error","delete#Delete":"Execute DELETE query.","signature-4#Signature":"func Delete(tx *sql.Tx, query string, args ...any) error"}},"/api-reference/postgresql/uuid-support":{"title":"UUID Support","data":{"":"PostgreSQL module includes built-in UUID support for string-based primary keys.","insertgenericuuid#InsertGenericUuid":"Auto-generates UUID for new entities.\nentity := &Entity{Name: \"My Entity\"}\nuuid, err := lpg.InsertGenericUuid(tx, entity)\n// entity.Id is set to generated UUID","insertgenericexistinguuid#InsertGenericExistingUuid":"Use pre-generated UUID.\nentity := &Entity{\n    Id:   uuid.New().String(),\n    Name: \"My Entity\",\n}\nerr := lpg.InsertGenericExistingUuid(tx, entity)","database-schema#Database Schema":"CREATE TABLE entities (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    name TEXT NOT NULL\n);\nSee PostgreSQL Guide for complete documentation."}},"/api-reference/mysql/overview":{"title":"MySQL Module Overview","data":{"":"The lmy package provides MySQL-specific implementations of go-lightning.","installation#Installation":"go get github.com/tracewayapp/go-lightning/lmy","import#Import":"import \"github.com/tracewayapp/go-lightning/lmy\"","key-features#Key Features":"Parameter placeholders: ?\nINSERT with AUTO_INCREMENT: Uses NULL + LastInsertId()\nUUID support: Same as PostgreSQL\nSimpler parameters: No renumbering needed","quick-reference#Quick Reference":"// Registration\nlmy.Register[User]()\n// SELECT operations\nusers, err := lmy.SelectGeneric[User](tx, query, args...)\nuser, err := lmy.SelectGenericSingle[User](tx, query, args...)\n// INSERT operations\nid, err := lmy.InsertGeneric(tx, &user)\nuuid, err := lmy.InsertGenericUuid(tx, &entity)\n// UPDATE/DELETE\nerr := lmy.UpdateGeneric(tx, &user, where, args...)\nerr := lmy.Delete(tx, query, args...)\n// Helpers\nplaceholders := lmy.JoinStringForIn(0, params)  // All ?\nSee MySQL Guide for comprehensive documentation."}},"/api-reference/postgresql/overview":{"title":"PostgreSQL Module Overview","data":{"":"The lpg package provides PostgreSQL-specific implementations of go-lightning.","installation#Installation":"go get github.com/tracewayapp/go-lightning/lpg","import#Import":"import \"github.com/tracewayapp/go-lightning/lpg\"","key-features#Key Features":"Parameter placeholders: $1, $2, $3...\nINSERT with RETURNING: Uses RETURNING id clause\nUUID support: Built-in UUID generation\nParameter renumbering: Automatic $N adjustment in WHERE clauses","quick-reference#Quick Reference":"// Registration\nlpg.Register[User]()\n// SELECT operations\nusers, err := lpg.SelectGeneric[User](tx, query, args...)\nuser, err := lpg.SelectGenericSingle[User](tx, query, args...)\n// INSERT operations\nid, err := lpg.InsertGeneric(tx, &user)\nuuid, err := lpg.InsertGenericUuid(tx, &entity)\n// UPDATE/DELETE\nerr := lpg.UpdateGeneric(tx, &user, where, args...)\nerr := lpg.Delete(tx, query, args...)\n// Helpers\nplaceholders := lpg.JoinStringForIn(offset, params)\nSee PostgreSQL Guide for comprehensive documentation."}},"/api-reference/postgresql/parameter-handling":{"title":"Parameter Handling","data":{"":"PostgreSQL uses numbered placeholders ($1, $2, $3) which require special handling.","joinstringforin#JoinStringForIn":"Generate parameterized IN clause placeholders with offset support.","signature#Signature":"func JoinStringForIn(offset int, params []string) string","examples#Examples":"// Basic usage\nparams := []string{\"a\", \"b\", \"c\"}\nplaceholders := lpg.JoinStringForIn(0, params)\n// Returns: \"$1,$2,$3\"\nquery := fmt.Sprintf(\"SELECT * FROM users WHERE name IN (%s)\", placeholders)\nusers, err := lpg.SelectGeneric[User](tx, query, params...)\n// With offset\nage := 25\nnames := []string{\"Alice\", \"Bob\"}\nplaceholders := lpg.JoinStringForIn(1, names)  // offset=1\n// Returns: \"$2,$3\"\nquery := fmt.Sprintf(\"SELECT * FROM users WHERE age > $1 AND name IN (%s)\", placeholders)\nusers, err := lpg.SelectGeneric[User](tx, query, age, names...)","automatic-renumbering-in-updategeneric#Automatic Renumbering in UpdateGeneric":"WHERE clause parameters are automatically renumbered:\nlpg.UpdateGeneric(tx, user, \"id = $1 AND status = $2\", userId, \"active\")\n// $1 becomes $N+1 where N is the number of SET parameters\nSee PostgreSQL Guide for details."}},"/contributing/development":{"title":"Development Setup","data":{"":"Guide for contributing to go-lightning.","repository-structure#Repository Structure":"go-lightning/\n├── lightning.go          # Core library\n├── lightning_test.go     # Core tests\n├── lpg/                  # PostgreSQL module\n│   ├── lpg.go\n│   ├── lpg_test.go\n│   └── examples/\n├── lmy/                  # MySQL module\n│   ├── lmy.go\n│   ├── lmy_test.go\n│   └── examples/\n└── go.work               # Go workspace","setup#Setup":"# Clone repository\ngit clone https://github.com/tracewayapp/go-lightning.git\ncd go-lightning\n# Install dependencies\ngo mod download\n# Sync workspace\ngo work sync","running-tests#Running Tests":"# All tests\ngo test ./...\n# Specific module\ngo test ./lpg/...\ngo test ./lmy/...\n# With coverage\ngo test -cover ./...\n# Verbose\ngo test -v ./...","code-organization#Code Organization":"Core (lightning.go): Database-agnostic generic operations\nPostgreSQL (lpg/): PostgreSQL-specific implementations\nMySQL (lmy/): MySQL-specific implementations","adding-a-new-database#Adding a New Database":"Create new package (e.g., lsqlite/)\nImplement InsertUpdateQueryGenerator\nCreate convenience Register[T]() function\nAdd tests\nAdd examples\nSee existing modules for reference."}},"/contributing/testing":{"title":"Testing","data":{"":"Testing philosophy and practices for go-lightning.","test-categories#Test Categories":"","unit-tests#Unit Tests":"Pure functions without database dependencies:\nfunc TestNamingStrategy(t *testing.T) {\n    strategy := DefaultDbNamingStrategy{}\n    result := strategy.GetTableNameFromStructName(\"User\")\n    assert.Equal(t, \"users\", result)\n}","integration-tests#Integration Tests":"Tests using sqlmock:\nimport \"github.com/DATA-DOG/go-sqlmock\"\nfunc TestInsertGeneric(t *testing.T) {\n    db, mock, _ := sqlmock.New()\n    defer db.Close()\n    mock.ExpectBegin()\n    mock.ExpectQuery(\"INSERT INTO users\").\n        WillReturnRows(sqlmock.NewRows([]string{\"id\"}).AddRow(1))\n    mock.ExpectCommit()\n    tx, _ := db.Begin()\n    id, err := lpg.InsertGeneric(tx, &User{Name: \"Test\"})\n    assert.NoError(t, err)\n    assert.Equal(t, 1, id)\n}","running-tests#Running Tests":"# All tests\ngo test ./...\n# With coverage\ngo test -cover ./...\n# Specific test\ngo test -run TestRegister ./...","test-structs#Test Structs":"Common test structs used:\nTestUser - Integer ID\nTestProduct - String ID\nTestUuidEntity - UUID field","coverage-expectations#Coverage Expectations":"Core functions: >80%\nDatabase modules: >70%\nIntegration tests for all operations"}},"/examples/advanced-queries":{"title":"Advanced Queries","data":{"":"Examples of complex queries with go-lightning.","join-queries#JOIN Queries":"Use manual operations for JOINs:\ntype UserWithProfile struct {\n    UserId      int\n    UserName    string\n    ProfileBio  string\n}\nfunc mapUserProfile(rows *sql.Rows, u *UserWithProfile) error {\n    return rows.Scan(&u.UserId, &u.UserName, &u.ProfileBio)\n}\nresults, err := lpg.SelectMultiple[UserWithProfile](tx, mapUserProfile, `\n    SELECT u.id, u.name, p.bio\n    FROM users u\n    JOIN profiles p ON p.user_id = u.id\n    WHERE u.active = $1\n`, true)","in-clauses#IN Clauses":"ids := []int{1, 2, 3, 4, 5}\nquery := fmt.Sprintf(\"SELECT * FROM users WHERE id IN (%s)\",\n    lpg.JoinForIn(ids))\nusers, err := lpg.SelectGeneric[User](tx, query)","aggregations#Aggregations":"type UserCount struct {\n    City  string\n    Count int\n}\nfunc mapCount(rows *sql.Rows, uc *UserCount) error {\n    return rows.Scan(&uc.City, &uc.Count)\n}\ncounts, err := lpg.SelectMultiple[UserCount](tx, mapCount, `\n    SELECT city, COUNT(*) as count\n    FROM users\n    GROUP BY city\n    ORDER BY count DESC\n`)","pagination#Pagination":"page := 1\npageSize := 20\noffset := (page - 1) * pageSize\nusers, err := lpg.SelectGeneric[User](tx,\n    \"SELECT * FROM users ORDER BY id LIMIT $1 OFFSET $2\",\n    pageSize, offset)\nSee guides for more complex patterns."}},"/api-reference/postgresql/crud-operations":{"title":"PostgreSQL CRUD Operations","data":{"":"Complete reference for PostgreSQL-specific CRUD operations.All operations are in the lpg package and support PostgreSQL-specific features.","see-core-documentation#See Core Documentation":"Most operations delegate to core implementations with PostgreSQL-specific query generation:\nGeneric Operations - Core generic functions\nManual Operations - Core manual functions","postgresql-specific-differences#PostgreSQL-Specific Differences":"","insertgeneric#InsertGeneric":"Uses QueryRow with RETURNING id clause instead of LastInsertId().\nid, err := lpg.InsertGeneric(tx, &user)\n// Executes: INSERT INTO users (...) VALUES ($1, $2) RETURNING id","updategeneric#UpdateGeneric":"Automatically renumbers $N placeholders in WHERE clause:\nlpg.UpdateGeneric(tx, user, \"id = $1\", userId)\n// WHERE parameter $1 becomes $4 (after SET parameters)","joinstringforin#JoinStringForIn":"Generates parameterized placeholders for IN clauses:\nparams := []string{\"a\", \"b\", \"c\"}\nplaceholders := lpg.JoinStringForIn(0, params)\n// Returns: \"$1,$2,$3\"\n// With offset\nplaceholders := lpg.JoinStringForIn(2, params)\n// Returns: \"$3,$4,$5\"\nSee PostgreSQL Guide for detailed examples."}},"/api-reference/core/interfaces":{"title":"Core Interfaces","data":{"":"Documentation for core interfaces in the go-lightning library.","dbnamingstrategy#DbNamingStrategy":"Controls how Go struct and field names are converted to database table and column names.","interface-definition#Interface Definition":"type DbNamingStrategy interface {\n    GetTableNameFromStructName(string) string\n    GetColumnNameFromStructName(string) string\n}","methods#Methods":"","gettablenamefromstructname#GetTableNameFromStructName":"Converts a Go struct name to a database table name.Signature:\nGetTableNameFromStructName(structName string) string\nParameters:\nstructName - The name of the Go struct (e.g., \"UserProfile\")\nReturns:\nTable name for the database (e.g., \"user_profiles\")\nExample:\nstrategy := DefaultDbNamingStrategy{}\ntableName := strategy.GetTableNameFromStructName(\"User\")  // Returns \"users\"","getcolumnnamefromstructname#GetColumnNameFromStructName":"Converts a Go field name to a database column name.Signature:\nGetColumnNameFromStructName(fieldName string) string\nParameters:\nfieldName - The name of the struct field (e.g., \"FirstName\")\nReturns:\nColumn name for the database (e.g., \"first_name\")\nExample:\nstrategy := DefaultDbNamingStrategy{}\ncolumnName := strategy.GetColumnNameFromStructName(\"FirstName\")  // Returns \"first_name\"","default-implementation#Default Implementation":"type DefaultDbNamingStrategy struct{}\nConversion rules:\nTable names: CamelCase → snake_case + 's' suffix\nUser → users\nUserProfile → user_profiles\nColumn names: CamelCase → snake_case\nFirstName → first_name\nEmailAddress → email_address\nExample:\nimport \"github.com/tracewayapp/go-lightning\"\nstrategy := lightning.DefaultDbNamingStrategy{}","see-also#See Also":"Naming Strategies Guide - Comprehensive guide with custom examples\nRegistration Guide - How naming strategies are used","insertupdatequerygenerator#InsertUpdateQueryGenerator":"Generates database-specific INSERT and UPDATE query templates.","interface-definition-1#Interface Definition":"type InsertUpdateQueryGenerator interface {\n    GenerateInsertQuery(tableName string, columnKeys []string, hasIntId bool) (string, []string)\n    GenerateUpdateQuery(tableName string, columnKeys []string) string\n}","methods-1#Methods":"","generateinsertquery#GenerateInsertQuery":"Generates an INSERT query template for the given table and columns.Signature:\nGenerateInsertQuery(tableName string, columnKeys []string, hasIntId bool) (string, []string)\nParameters:\ntableName - Database table name\ncolumnKeys - All column names from the struct\nhasIntId - Whether the struct has an integer Id field\nReturns:\nstring - INSERT query template\n[]string - List of columns to include in INSERT (may exclude auto-increment ID)\nPostgreSQL Example:\ngenerator := PgInsertUpdateQueryGenerator{}\nquery, cols := generator.GenerateInsertQuery(\"users\", []string{\"id\", \"name\", \"email\"}, true)\n// query: \"INSERT INTO users (id, name, email) VALUES (DEFAULT, $1, $2) RETURNING id\"\n// cols: [\"name\", \"email\"]\nMySQL Example:\ngenerator := MySqlInsertUpdateQueryGenerator{}\nquery, cols := generator.GenerateInsertQuery(\"users\", []string{\"id\", \"name\", \"email\"}, true)\n// query: \"INSERT INTO users (id, name, email) VALUES (NULL, ?, ?)\"\n// cols: [\"name\", \"email\"]","generateupdatequery#GenerateUpdateQuery":"Generates an UPDATE query template (without WHERE clause).Signature:\nGenerateUpdateQuery(tableName string, columnKeys []string) string\nParameters:\ntableName - Database table name\ncolumnKeys - All column names to update\nReturns:\nUPDATE query template (WHERE clause is appended at call time)\nPostgreSQL Example:\ngenerator := PgInsertUpdateQueryGenerator{}\nquery := generator.GenerateUpdateQuery(\"users\", []string{\"id\", \"name\", \"email\"})\n// Returns: \"UPDATE users SET id = $1, name = $2, email = $3 WHERE \"\nMySQL Example:\ngenerator := MySqlInsertUpdateQueryGenerator{}\nquery := generator.GenerateUpdateQuery(\"users\", []string{\"id\", \"name\", \"email\"})\n// Returns: \"UPDATE users SET id = ?, name = ?, email = ? WHERE \"","database-implementations#Database Implementations":"","postgresql-pginsertupdatequerygenerator#PostgreSQL: PgInsertUpdateQueryGenerator":"Available in github.com/tracewayapp/go-lightning/lpgFeatures:\nUses $1, $2, $3 parameter placeholders\nINSERT uses DEFAULT for auto-increment fields\nIncludes RETURNING id clause\nimport \"github.com/tracewayapp/go-lightning/lpg\"\ngenerator := lpg.PgInsertUpdateQueryGenerator{}","mysql-mysqlinsertupdatequerygenerator#MySQL: MySqlInsertUpdateQueryGenerator":"Available in github.com/tracewayapp/go-lightning/lmyFeatures:\nUses ? parameter placeholders\nINSERT uses NULL for auto-increment fields\nNo RETURNING clause (uses LastInsertId())\nimport \"github.com/tracewayapp/go-lightning/lmy\"\ngenerator := lmy.MySqlInsertUpdateQueryGenerator{}","see-also-1#See Also":"PostgreSQL Guide - PostgreSQL-specific features\nMySQL Guide - MySQL-specific features\nRegistration Guide - How query generators are used","fieldmap#FieldMap":"Pre-computed metadata about a registered struct type, used for efficient query execution.","structure-definition#Structure Definition":"type FieldMap struct {\n    ColumnsMap    map[string]int  // Column name → struct field index\n    ColumnKeys    []string         // Ordered list of all column names\n    HasIntId      bool             // True if struct has integer Id field\n    InsertQuery   string           // Pre-built INSERT query template\n    UpdateQuery   string           // Pre-built UPDATE query template\n    InsertColumns []string         // Columns for INSERT (excludes auto-increment id)\n}","fields#Fields":"","columnsmap#ColumnsMap":"Maps column names to struct field indices for fast lookups.Type: map[string]intExample:\nColumnsMap: {\n    \"id\":         0,\n    \"first_name\": 1,\n    \"last_name\":  2,\n    \"email\":      3,\n}\nUsed for:\nValidating SELECT query columns\nBuilding scan destination pointers in correct order","columnkeys#ColumnKeys":"Ordered list of all column names.Type: []stringExample:\nColumnKeys: [\"id\", \"first_name\", \"last_name\", \"email\"]\nUsed for:\nGenerating UPDATE SET clauses\nIterating fields in consistent order","hasintid#HasIntId":"Indicates whether the struct has an integer Id field for auto-increment handling.Type: boolExample:\ntype User struct {\n    Id int  // HasIntId = true\n}\ntype Entity struct {\n    Id string  // HasIntId = false (UUID)\n}","insertquery#InsertQuery":"Pre-built INSERT query template.Type: stringExample (PostgreSQL):\nInsertQuery: \"INSERT INTO users (first_name, last_name, email) VALUES ($1, $2, $3) RETURNING id\"\nExample (MySQL):\nInsertQuery: \"INSERT INTO users (id, first_name, last_name, email) VALUES (NULL, ?, ?, ?)\"","updatequery#UpdateQuery":"Pre-built UPDATE query template (without WHERE clause).Type: stringExample:\nUpdateQuery: \"UPDATE users SET first_name = $1, last_name = $2, email = $3 WHERE \"","insertcolumns#InsertColumns":"List of columns to include in INSERT operations (excludes auto-increment ID).Type: []stringExample:\nInsertColumns: [\"first_name\", \"last_name\", \"email\"]  // \"id\" excluded","retrieving-fieldmap#Retrieving FieldMap":"Use GetFieldMap to retrieve the FieldMap for a registered type:\nimport (\n    \"reflect\"\n    golightning \"github.com/tracewayapp/go-lightning\"\n)\nuserType := reflect.TypeOf(User{})\nfieldMap, err := golightning.GetFieldMap(userType)\nif err != nil {\n    log.Fatal(\"User not registered:\", err)\n}\nfmt.Println(\"Columns:\", fieldMap.ColumnKeys)\nfmt.Println(\"INSERT:\", fieldMap.InsertQuery)","see-also-2#See Also":"Registration Guide - Deep dive into FieldMap creation\nCore Concepts - Architecture overview"}},"/examples/custom-naming":{"title":"Custom Naming Strategy Example","data":{"":"Implementing custom naming strategies for different table/column conventions.","example-prefix-tables#Example: Prefix Tables":"package main\nimport (\n    \"strings\"\n    \"unicode\"\n    golightning \"github.com/tracewayapp/go-lightning\"\n    \"github.com/tracewayapp/go-lightning/lpg\"\n)\ntype PrefixedNamingStrategy struct {\n    Prefix string\n}\nfunc (s PrefixedNamingStrategy) GetTableNameFromStructName(structName string) string {\n    return s.Prefix + toSnakeCase(structName) + \"s\"\n}\nfunc (s PrefixedNamingStrategy) GetColumnNameFromStructName(fieldName string) string {\n    return toSnakeCase(fieldName)\n}\nfunc toSnakeCase(s string) string {\n    var result []rune\n    for i, r := range s {\n        if unicode.IsUpper(r) {\n            if i > 0 {\n                result = append(result, '_')\n            }\n            result = append(result, unicode.ToLower(r))\n        } else {\n            result = append(result, r)\n        }\n    }\n    return string(result)\n}\ntype User struct {\n    Id   int\n    Name string\n}\nfunc init() {\n    golightning.Register[User](\n        PrefixedNamingStrategy{Prefix: \"app_\"},\n        lpg.PgInsertUpdateQueryGenerator{},\n    )\n}\n// User → app_users table\n// Name → name column\nSee Naming Strategies Guide for more examples."}},"/examples/uuid-entities":{"title":"UUID Entities Example","data":{"":"Using UUID primary keys instead of auto-increment integers.","entity-with-uuid#Entity with UUID":"package models\nimport \"github.com/tracewayapp/go-lightning/lpg\"\ntype Entity struct {\n    Id          string  // UUID stored as string\n    Name        string\n    Description string\n}\nfunc init() {\n    lpg.Register[Entity]()\n}","auto-generated-uuid#Auto-Generated UUID":"entity := &Entity{\n    Name:        \"My Entity\",\n    Description: \"Description here\",\n}\n// Generates UUID automatically\nuuid, err := lpg.InsertGenericUuid(tx, entity)\nif err != nil {\n    log.Fatal(err)\n}\nfmt.Printf(\"Generated UUID: %s\\n\", uuid)\nfmt.Printf(\"Entity ID: %s\\n\", entity.Id)  // Same as uuid","pre-generated-uuid#Pre-Generated UUID":"import \"github.com/google/uuid\"\nentity := &Entity{\n    Id:          uuid.New().String(),\n    Name:        \"My Entity\",\n    Description: \"Description\",\n}\nerr := lpg.InsertGenericExistingUuid(tx, entity)\nif err != nil {\n    log.Fatal(err)\n}","postgresql-schema#PostgreSQL Schema":"CREATE TABLE entities (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    name TEXT NOT NULL,\n    description TEXT\n);","mysql-schema#MySQL Schema":"CREATE TABLE entities (\n    id CHAR(36) PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    description TEXT\n);\nSee PostgreSQL Guide for more details."}},"/examples/mysql-complete":{"title":"MySQL Complete Example","data":{"":"Complete MySQL example with go-lightning.","key-differences-from-postgresql#Key Differences from PostgreSQL":"Uses lmy package instead of lpg\nConnection string format\nParameter placeholders: ? instead of $1, $2","complete-code#Complete Code":"package main\nimport (\n    \"database/sql\"\n    \"fmt\"\n    \"log\"\n    \"yourproject/models\"\n    _ \"github.com/go-sql-driver/mysql\"\n    \"github.com/tracewayapp/go-lightning/lmy\"\n)\nfunc main() {\n    db, err := sql.Open(\"mysql\",\n        \"user:password@tcp(localhost:3306)/dbname?parseTime=true\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer db.Close()\n    tx, err := db.Begin()\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer tx.Rollback()\n    // INSERT\n    id, err := lmy.InsertGeneric(tx, &models.User{\n        FirstName: \"John\",\n        LastName:  \"Doe\",\n        Email:     \"john.doe@example.com\",\n    })\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Printf(\"Inserted ID: %d\\n\", id)\n    // SELECT with ? placeholder\n    user, err := lmy.SelectGenericSingle[models.User](tx,\n        \"SELECT * FROM users WHERE id = ?\", id)\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Printf(\"Found: %s %s\\n\", user.FirstName, user.LastName)\n    // UPDATE\n    user.FirstName = \"Jane\"\n    err = lmy.UpdateGeneric(tx, user, \"id = ?\", id)\n    if err != nil {\n        log.Fatal(err)\n    }\n    tx.Commit()\n    fmt.Println(\"Success!\")\n}","modelsusergo#models/user.go":"package models\nimport \"github.com/tracewayapp/go-lightning/lmy\"\ntype User struct {\n    Id        int\n    FirstName string\n    LastName  string\n    Email     string\n}\nfunc init() {\n    lmy.Register[User]()  // MySQL registration\n}","schema#Schema":"CREATE TABLE users (\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    first_name VARCHAR(255) NOT NULL,\n    last_name VARCHAR(255) NOT NULL,\n    email VARCHAR(255) UNIQUE NOT NULL\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nSee MySQL Guide for more details."}},"/examples/postgresql-complete":{"title":"PostgreSQL Complete Example","data":{"":"Complete working example with go-lightning and PostgreSQL, including error handling and best practices.This example is based on the actual code in lpg/examples/userscrud/.","project-structure#Project Structure":"project/\n├── go.mod\n├── main.go\n└── models/\n    └── user.go","modelsusergo#models/user.go":"package models\nimport \"github.com/tracewayapp/go-lightning/lpg\"\ntype User struct {\n    Id        int\n    FirstName string\n    LastName  string\n    Email     string\n}\nfunc init() {\n    lpg.Register[User]()\n}","maingo#main.go":"package main\nimport (\n    \"database/sql\"\n    \"fmt\"\n    \"log\"\n    \"yourproject/models\"\n    _ \"github.com/jackc/pgx/v5/stdlib\"\n    \"github.com/tracewayapp/go-lightning/lpg\"\n)\nfunc main() {\n    db, err := sql.Open(\"pgx\",\n        \"postgres://user:password@localhost:5432/dbname?sslmode=disable\")\n    if err != nil {\n        log.Fatalf(\"Unable to connect: %v\\n\", err)\n    }\n    defer db.Close()\n    tx, err := db.Begin()\n    if err != nil {\n        log.Fatalf(\"Failed to begin transaction: %v\\n\", err)\n    }\n    defer tx.Rollback()\n    // INSERT\n    id, err := lpg.InsertGeneric(tx, &models.User{\n        FirstName: \"John\",\n        LastName:  \"Doe\",\n        Email:     \"john.doe@example.com\",\n    })\n    if err != nil {\n        log.Fatalf(\"Insert failed: %v\\n\", err)\n    }\n    fmt.Printf(\"Inserted user with ID: %d\\n\", id)\n    // SELECT SINGLE\n    user, err := lpg.SelectGenericSingle[models.User](tx,\n        \"SELECT * FROM users WHERE id = $1\", id)\n    if err != nil {\n        log.Fatalf(\"Select failed: %v\\n\", err)\n    }\n    if user != nil {\n        fmt.Printf(\"Found: %s %s (%s)\\n\",\n            user.FirstName, user.LastName, user.Email)\n    }\n    // SELECT MULTIPLE\n    users, err := lpg.SelectGeneric[models.User](tx,\n        \"SELECT * FROM users LIMIT 5\")\n    if err != nil {\n        log.Fatalf(\"Select multiple failed: %v\\n\", err)\n    }\n    fmt.Printf(\"Found %d users\\n\", len(users))\n    // UPDATE\n    user.FirstName = \"Jane\"\n    err = lpg.UpdateGeneric(tx, user, \"id = $1\", id)\n    if err != nil {\n        log.Fatalf(\"Update failed: %v\\n\", err)\n    }\n    fmt.Println(\"Updated user\")\n    // DELETE\n    err = lpg.Delete(tx, \"DELETE FROM users WHERE id = $1\", id)\n    if err != nil {\n        log.Fatalf(\"Delete failed: %v\\n\", err)\n    }\n    fmt.Printf(\"Deleted user %d\\n\", id)\n    // Commit\n    if err := tx.Commit(); err != nil {\n        log.Fatalf(\"Commit failed: %v\\n\", err)\n    }\n    fmt.Println(\"CRUD example completed successfully!\")\n}","database-schema#Database Schema":"CREATE TABLE IF NOT EXISTS users (\n    id SERIAL PRIMARY KEY,\n    first_name TEXT NOT NULL,\n    last_name TEXT NOT NULL,\n    email TEXT UNIQUE NOT NULL\n);\nSee Quick Start for more details."}},"/getting-started/installation":{"title":"Installation","data":{"prerequisites#Prerequisites":"Go 1.25.1 or higher - go-lightning uses Go generics (introduced in Go 1.18)\nA supported database (PostgreSQL or MySQL)\nAppropriate database driver","choose-your-database#Choose Your Database":"go-lightning provides database-specific modules for PostgreSQL and MySQL. Choose the one that matches your database.","postgresql-installation#PostgreSQL Installation":"Install the PostgreSQL module:\ngo get github.com/tracewayapp/go-lightning/lpg\nYou'll also need a PostgreSQL driver. The recommended driver is pgx:\ngo get github.com/jackc/pgx/v5\ngo get github.com/jackc/pgx/v5/stdlib","mysql-installation#MySQL Installation":"Install the MySQL module:\ngo get github.com/tracewayapp/go-lightning/lmy\nYou'll also need a MySQL driver:\ngo get github.com/go-sql-driver/mysql","core-library-optional#Core Library (Optional)":"If you want to use the core generic utilities without database-specific implementations:\ngo get github.com/tracewayapp/go-lightning\nMost users will use the database-specific modules (lpg or lmy) which already include the core library.","verify-installation#Verify Installation":"Create a simple Go file to verify the installation:","postgresql-verification#PostgreSQL Verification":"package main\nimport (\n    \"database/sql\"\n    _ \"github.com/jackc/pgx/v5/stdlib\"\n    \"github.com/tracewayapp/go-lightning/lpg\"\n)\ntype User struct {\n    Id        int\n    FirstName string\n    LastName  string\n    Email     string\n}\nfunc init() {\n    lpg.Register[User]()\n}\nfunc main() {\n    println(\"go-lightning for PostgreSQL installed successfully!\")\n}\nRun it:\ngo run main.go\nIf you see the success message, you're all set!","mysql-verification#MySQL Verification":"package main\nimport (\n    \"database/sql\"\n    _ \"github.com/go-sql-driver/mysql\"\n    \"github.com/tracewayapp/go-lightning/lmy\"\n)\ntype User struct {\n    Id        int\n    FirstName string\n    LastName  string\n    Email     string\n}\nfunc init() {\n    lmy.Register[User]()\n}\nfunc main() {\n    println(\"go-lightning for MySQL installed successfully!\")\n}\nRun it:\ngo run main.go","project-setup#Project Setup":"","typical-project-structure#Typical Project Structure":"myproject/\n├── go.mod\n├── go.sum\n├── main.go\n└── models/\n    ├── user.go       # User struct with registration\n    └── product.go    # Product struct with registration","modelsusergo-example#models/user.go Example":"package models\nimport \"github.com/tracewayapp/go-lightning/lpg\"\ntype User struct {\n    Id        int\n    FirstName string\n    LastName  string\n    Email     string\n}\nfunc init() {\n    lpg.Register[User]()  // Register during package initialization\n}","maingo-example#main.go Example":"package main\nimport (\n    \"database/sql\"\n    \"log\"\n    _ \"github.com/jackc/pgx/v5/stdlib\"\n    \"github.com/tracewayapp/go-lightning/lpg\"\n    \"myproject/models\"  // Import triggers init() and registration\n)\nfunc main() {\n    db, err := sql.Open(\"pgx\", \"postgres://user:pass@localhost/dbname\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer db.Close()\n    tx, _ := db.Begin()\n    defer tx.Rollback()\n    user := &models.User{\n        FirstName: \"Jane\",\n        LastName:  \"Doe\",\n        Email:     \"jane@example.com\",\n    }\n    id, err := lpg.InsertGeneric(tx, user)\n    if err != nil {\n        log.Fatal(err)\n    }\n    log.Printf(\"Inserted user with ID: %d\\n\", id)\n    tx.Commit()\n}","database-connection-strings#Database Connection Strings":"","postgresql#PostgreSQL":"// Standard connection string\n\"postgres://username:password@localhost:5432/database_name?sslmode=disable\"\n// Using environment variables\nimport \"os\"\nconnStr := os.Getenv(\"DATABASE_URL\")\ndb, err := sql.Open(\"pgx\", connStr)","mysql#MySQL":"// Standard connection string\n\"username:password@tcp(localhost:3306)/database_name?parseTime=true\"\n// Using environment variables\nimport \"os\"\nconnStr := os.Getenv(\"DATABASE_URL\")\ndb, err := sql.Open(\"mysql\", connStr)","troubleshooting#Troubleshooting":"","package-githubcomtracewayappgo-lightninglpg-is-not-in-goroot#\"package github.com/tracewayapp/go-lightning/lpg is not in GOROOT\"":"Make sure you've run go get:\ngo get github.com/tracewayapp/go-lightning/lpg\nAnd ensure your go.mod file includes the dependency:\nmodule myproject\ngo 1.25\nrequire github.com/tracewayapp/go-lightning v0.1.0","undefined-lpgregister#\"undefined: lpg.Register\"":"Make sure you're importing the correct package:\nimport \"github.com/tracewayapp/go-lightning/lpg\"  // PostgreSQL\n// or\nimport \"github.com/tracewayapp/go-lightning/lmy\"  // MySQL","sql-unknown-driver#\"sql: unknown driver\"":"You need to import the database driver:\nimport _ \"github.com/jackc/pgx/v5/stdlib\"  // PostgreSQL\n// or\nimport _ \"github.com/go-sql-driver/mysql\"  // MySQL\nThe _ blank identifier imports the package for its side effects (registering the driver).","next-steps#Next Steps":"Quick Start - Build your first application\nCore Concepts - Understand how go-lightning works\nPostgreSQL Guide - PostgreSQL-specific features\nMySQL Guide - MySQL-specific features"}},"/guides/mysql":{"title":"MySQL Guide","data":{"":"This guide covers MySQL-specific features and best practices when using go-lightning with MySQL.","installation#Installation":"go get github.com/tracewayapp/go-lightning/lmy\ngo get github.com/go-sql-driver/mysql","basic-setup#Basic Setup":"","import-and-driver-registration#Import and Driver Registration":"package main\nimport (\n    \"database/sql\"\n    _ \"github.com/go-sql-driver/mysql\"  // MySQL driver\n    \"github.com/tracewayapp/go-lightning/lmy\"\n    \"yourproject/models\"\n)","connection-string#Connection String":"db, err := sql.Open(\"mysql\", \"user:password@tcp(localhost:3306)/dbname?parseTime=true\")\nif err != nil {\n    log.Fatal(err)\n}\ndefer db.Close()\nImportant parameters:\nparseTime=true - Required for scanning time.Time fields\ncharset=utf8mb4 - Recommended for full Unicode support\nloc=Local - Use local timezone\nFull example:\ndsn := \"user:password@tcp(localhost:3306)/dbname?parseTime=true&charset=utf8mb4&loc=Local\"\ndb, err := sql.Open(\"mysql\", dsn)","parameter-placeholders#Parameter Placeholders":"MySQL uses question mark placeholders: ?\n// Single parameter\nuser, err := lmy.SelectGenericSingle[User](tx,\n    \"SELECT * FROM users WHERE id = ?\", userId)\n// Multiple parameters\nusers, err := lmy.SelectGeneric[User](tx,\n    \"SELECT * FROM users WHERE age > ? AND city = ?\", 25, \"New York\")\n// IN clause\nids := []int{1, 2, 3}\nquery := fmt.Sprintf(\"SELECT * FROM users WHERE id IN (%s)\",\n    lmy.JoinForIn(ids))\nusers, err := lmy.SelectGeneric[User](tx, query)\nNote: Unlike PostgreSQL's $1, $2, MySQL placeholders are positional and unnamed.","insert-with-auto_increment#INSERT with AUTO_INCREMENT":"MySQL's lmy.InsertGeneric uses NULL for auto-increment fields and retrieves the ID via LastInsertId():\nuser := &User{\n    FirstName: \"John\",\n    LastName:  \"Doe\",\n    Email:     \"john@example.com\",\n}\nid, err := lmy.InsertGeneric(tx, user)\nif err != nil {\n    log.Fatal(err)\n}\nfmt.Printf(\"Inserted user with ID: %d\\n\", id)\nGenerated SQL:\nINSERT INTO users (id, first_name, last_name, email)\nVALUES (NULL, ?, ?, ?)\nKey differences from PostgreSQL:\nUses NULL instead of DEFAULT for auto-increment ID\nNo RETURNING clause (MySQL doesn't support it)\nUses LastInsertId() to retrieve generated ID","transaction-patterns#Transaction Patterns":"","basic-transaction#Basic Transaction":"tx, err := db.Begin()\nif err != nil {\n    return err\n}\ndefer tx.Rollback()  // Safe even after Commit()\n// Operations\nid, err := lmy.InsertGeneric(tx, &user)\nif err != nil {\n    return err  // Rollback via defer\n}\n// Commit\nif err := tx.Commit(); err != nil {\n    return err\n}","transaction-with-isolation-level#Transaction with Isolation Level":"tx, err := db.BeginTx(context.Background(), &sql.TxOptions{\n    Isolation: sql.LevelRepeatableRead,\n})\nMySQL isolation levels:\nsql.LevelReadUncommitted\nsql.LevelReadCommitted\nsql.LevelRepeatableRead - MySQL default\nsql.LevelSerializable","dynamic-in-clauses#Dynamic IN Clauses":"","for-integer-ids#For Integer IDs":"Use JoinForIn to build comma-separated lists:\nids := []int{1, 2, 3, 4, 5}\nquery := fmt.Sprintf(\"SELECT * FROM users WHERE id IN (%s)\", lmy.JoinForIn(ids))\nusers, err := lmy.SelectGeneric[User](tx, query)\nOutput: SELECT * FROM users WHERE id IN (1,2,3,4,5)","for-parameterized-in-clauses#For Parameterized IN Clauses":"Use JoinStringForIn:\nusernames := []string{\"alice\", \"bob\", \"charlie\"}\nquery := fmt.Sprintf(\"SELECT * FROM users WHERE username IN (%s)\",\n    lmy.JoinStringForIn(0, usernames))\nusers, err := lmy.SelectGeneric[User](tx, query, usernames...)\nOutput:\nQuery: SELECT * FROM users WHERE username IN (?,?,?)\nArgs: [\"alice\", \"bob\", \"charlie\"]\nNote: The offset parameter in JoinStringForIn is ignored for MySQL because all placeholders are ?. It's included for API compatibility with PostgreSQL.\n// Both produce the same result in MySQL\nlmy.JoinStringForIn(0, params)  // -> \"?,?,?\"\nlmy.JoinStringForIn(5, params)  // -> \"?,?,?\"  (offset ignored)","best-practices#Best Practices":"","1-always-use-parsetimetrue#1. Always Use parseTime=true":"Without this, time.Time fields won't scan correctly:\n// ❌ Will fail to scan dates\ndb, _ := sql.Open(\"mysql\", \"user:pass@tcp(host)/db\")\n// ✅ Correct\ndb, _ := sql.Open(\"mysql\", \"user:pass@tcp(host)/db?parseTime=true\")","2-use-utf8mb4-for-unicode#2. Use utf8mb4 for Unicode":"dsn := \"user:pass@tcp(host)/db?parseTime=true&charset=utf8mb4\"\nSchema:\nCREATE TABLE users (\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    name VARCHAR(255),\n    email VARCHAR(255)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;","3-use-connection-pooling#3. Use Connection Pooling":"db.SetMaxOpenConns(25)\ndb.SetMaxIdleConns(5)\ndb.SetConnMaxLifetime(5 * time.Minute)","4-prefer-innodb-engine#4. Prefer InnoDB Engine":"CREATE TABLE users (\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    name VARCHAR(255)\n) ENGINE=InnoDB;  -- Recommended over MyISAM\nWhy InnoDB:\nSupports transactions (required for go-lightning)\nForeign key constraints\nRow-level locking\nBetter concurrency","5-handle-null-values#5. Handle NULL Values":"type User struct {\n    Id        int\n    Name      string\n    Biography *string  // NULL-able column\n}\n// Insert with NULL\nuser := &User{\n    Name:      \"John\",\n    Biography: nil,  // Will be NULL in database\n}","uuid-support#UUID Support":"While MySQL can use UUIDs, it's less common than in PostgreSQL. go-lightning supports it:\ntype Entity struct {\n    Id          string  // VARCHAR(36) or CHAR(36)\n    Name        string\n    Description string\n}\nfunc init() {\n    lmy.Register[Entity]()\n}\n// Auto-generate UUID\nentity := &Entity{Name: \"My Entity\"}\nuuid, err := lmy.InsertGenericUuid(tx, entity)\n// Or use existing UUID\nentity.Id = uuid.New().String()\nerr := lmy.InsertGenericExistingUuid(tx, entity)\nSchema:\nCREATE TABLE entities (\n    id CHAR(36) PRIMARY KEY,  -- Fixed length for UUIDs\n    name VARCHAR(255),\n    description TEXT\n);\nNote: MySQL doesn't have a native UUID type. Use CHAR(36) or BINARY(16) with custom encoding.","mysql-specific-features#MySQL-Specific Features":"","json-support#JSON Support":"MySQL 5.7+ supports JSON columns:\ntype Product struct {\n    Id         int\n    Name       string\n    Attributes string  // JSON string\n}\n// Store JSON\nattrs := `{\"color\": \"red\", \"size\": \"large\"}`\nproduct := &Product{\n    Name:       \"T-Shirt\",\n    Attributes: attrs,\n}\nid, err := lmy.InsertGeneric(tx, product)\n// Query JSON\nproducts, err := lmy.SelectGeneric[Product](tx,\n    \"SELECT * FROM products WHERE JSON_EXTRACT(attributes, '$.color') = ?\", \"red\")\nSchema:\nCREATE TABLE products (\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    name VARCHAR(255),\n    attributes JSON\n);","full-text-search#Full-Text Search":"-- Create full-text index\nCREATE FULLTEXT INDEX idx_content ON articles(title, content);\n// Search\narticles, err := lmy.SelectGeneric[Article](tx,\n    \"SELECT * FROM articles WHERE MATCH(title, content) AGAINST (? IN NATURAL LANGUAGE MODE)\",\n    \"golang database\")","common-patterns#Common Patterns":"","upsert-insert--on-duplicate-key-update#Upsert (INSERT ... ON DUPLICATE KEY UPDATE)":"query := `\n    INSERT INTO users (id, name, email)\n    VALUES (?, ?, ?)\n    ON DUPLICATE KEY UPDATE name = VALUES(name)\n`\nresult, err := tx.Exec(query, user.Id, user.Name, user.Email)\nid, _ := result.LastInsertId()","bulk-insert#Bulk Insert":"query := `\n    INSERT INTO users (first_name, last_name, email)\n    VALUES (?, ?, ?), (?, ?, ?), (?, ?, ?)\n`\n_, err := tx.Exec(query,\n    \"John\", \"Doe\", \"john@example.com\",\n    \"Jane\", \"Doe\", \"jane@example.com\",\n    \"Bob\", \"Smith\", \"bob@example.com\",\n)","soft-deletes#Soft Deletes":"type User struct {\n    Id        int\n    Name      string\n    DeletedAt *time.Time  // NULL when not deleted\n}\n// Soft delete\nerr := lmy.Update(tx, \"UPDATE users SET deleted_at = NOW() WHERE id = ?\", userId)\n// Query only active users\nusers, err := lmy.SelectGeneric[User](tx,\n    \"SELECT * FROM users WHERE deleted_at IS NULL\")","differences-from-postgresql#Differences from PostgreSQL":"Feature\tPostgreSQL (lpg)\tMySQL (lmy)\tPlaceholders\t$1, $2, $3\t?\tINSERT Return\tRETURNING id\tLastInsertId()\tAuto-Increment\tSERIAL / IDENTITY\tAUTO_INCREMENT\tAuto-Increment INSERT\tDEFAULT\tNULL\tUUID Native Support\tYes (UUID type)\tNo (use CHAR/BINARY)\tArray Types\tYes\tNo\tParameter Renumbering\tYes (in UpdateGeneric)\tNo (not needed)\tJSON Type\tJSONB (binary)\tJSON (text-based)","parameter-renumbering#Parameter Renumbering":"PostgreSQL's lpg.UpdateGeneric automatically renumbers $N placeholders. MySQL doesn't need this because all placeholders are ?:\n// PostgreSQL\nlpg.UpdateGeneric(tx, user, \"id = $1\", userId)\n// WHERE parameter $1 is renumbered to $4 internally\n// MySQL\nlmy.UpdateGeneric(tx, user, \"id = ?\", userId)\n// No renumbering needed - just adds ? to end","troubleshooting#Troubleshooting":"","invalid-connection#\"invalid connection\"":"Check connection string format:\n// ❌ Wrong\n\"user:pass@localhost:3306/db\"\n// ✅ Correct\n\"user:pass@tcp(localhost:3306)/db\"","unsupported-scan-storing-drivervalue-type-uint8-into-type-timetime#\"unsupported Scan, storing driver.Value type []uint8 into type *time.Time\"":"Add parseTime=true to connection string:\n\"user:pass@tcp(host)/db?parseTime=true\"","error-1364-field-x-doesnt-have-a-default-value#\"Error 1364: Field 'X' doesn't have a default value\"":"Your schema requires a value but go-lightning isn't providing one. Options:\nAdd field to struct\nMake column NULL-able: ALTER TABLE users MODIFY column_name VARCHAR(255) NULL\nAdd default value: ALTER TABLE users MODIFY column_name VARCHAR(255) DEFAULT ''","error-2006-mysql-server-has-gone-away#\"Error 2006: MySQL server has gone away\"":"Connection was idle too long. Set connection lifetime:\ndb.SetConnMaxLifetime(5 * time.Minute)\ndb.SetMaxIdleConns(10)","error-1206-the-total-number-of-locks-exceeds-the-lock-table-size#\"Error 1206: The total number of locks exceeds the lock table size\"":"Increase InnoDB buffer pool size in my.cnf:\n[mysqld]\ninnodb_buffer_pool_size = 256M","version-compatibility#Version Compatibility":"go-lightning works with:\nMySQL 5.7+ - Recommended (JSON support, better performance)\nMySQL 8.0+ - Recommended (window functions, CTEs)\nMariaDB 10.2+ - Compatible","next-steps#Next Steps":"Transactions Guide - Advanced transaction patterns\nMySQL Complete Example - Full working example\nMySQL API Reference - Complete API documentation"}},"/guides/naming-strategies":{"title":"Naming Strategies","data":{"":"Learn how to customize the mapping between Go struct names and database table/column names.","overview#Overview":"Naming strategies control how go-lightning converts Go naming conventions (CamelCase) to database naming conventions (typically snake_case).","the-dbnamingstrategy-interface#The DbNamingStrategy Interface":"type DbNamingStrategy interface {\n    GetTableNameFromStructName(string) string\n    GetColumnNameFromStructName(string) string\n}\nTwo methods:\nGetTableNameFromStructName - Converts struct name → table name\nGetColumnNameFromStructName - Converts field name → column name","default-naming-strategy#Default Naming Strategy":"go-lightning uses DefaultDbNamingStrategy which implements standard conventions:","table-name-conversion#Table Name Conversion":"Rule: CamelCase → snake_case + add s suffixExamples:\n\"User\"           → \"users\"\n\"UserProfile\"    → \"user_profiles\"\n\"OrderHistory\"   → \"order_historys\"   // Simple suffix, not smart plural\n\"APIKey\"         → \"a_p_i_keys\"","column-name-conversion#Column Name Conversion":"Rule: CamelCase → snake_caseExamples:\n\"Id\"             → \"id\"\n\"FirstName\"      → \"first_name\"\n\"EmailAddress\"   → \"email_address\"\n\"IsActive\"       → \"is_active\"\n\"CreatedAt\"      → \"created_at\"\n\"JSONData\"       → \"j_s_o_n_data\"","default-strategy-implementation#Default Strategy Implementation":"The default strategy follows this algorithm:\ntype DefaultDbNamingStrategy struct{}\nfunc (DefaultDbNamingStrategy) GetTableNameFromStructName(structName string) string {\n    // Convert to snake_case\n    snake := toSnakeCase(structName)\n    // Add 's' suffix for pluralization\n    return snake + \"s\"\n}\nfunc (DefaultDbNamingStrategy) GetColumnNameFromStructName(fieldName string) string {\n    // Convert to snake_case\n    return toSnakeCase(fieldName)\n}\nfunc toSnakeCase(s string) string {\n    var result []rune\n    for i, r := range s {\n        if unicode.IsUpper(r) {\n            if i > 0 {\n                result = append(result, '_')\n            }\n            result = append(result, unicode.ToLower(r))\n        } else {\n            result = append(result, r)\n        }\n    }\n    return string(result)\n}","common-customizations#Common Customizations":"","1-no-pluralization#1. No Pluralization":"If your tables don't use plural names:\ntype NoPluralNamingStrategy struct{}\nfunc (NoPluralNamingStrategy) GetTableNameFromStructName(structName string) string {\n    return toSnakeCase(structName)  // No 's' suffix\n}\nfunc (NoPluralNamingStrategy) GetColumnNameFromStructName(fieldName string) string {\n    return toSnakeCase(fieldName)\n}\n// Usage\nfunc init() {\n    golightning.Register[User](\n        NoPluralNamingStrategy{},\n        lpg.PgInsertUpdateQueryGenerator{},\n    )\n}\nResult:\nUser → user (not users)\nProduct → product (not products)","2-table-prefix#2. Table Prefix":"Add a prefix to all table names:\ntype PrefixedNamingStrategy struct {\n    Prefix string\n}\nfunc (s PrefixedNamingStrategy) GetTableNameFromStructName(structName string) string {\n    return s.Prefix + toSnakeCase(structName) + \"s\"\n}\nfunc (s PrefixedNamingStrategy) GetColumnNameFromStructName(fieldName string) string {\n    return toSnakeCase(fieldName)\n}\n// Usage\nfunc init() {\n    golightning.Register[User](\n        PrefixedNamingStrategy{Prefix: \"app_\"},\n        lpg.PgInsertUpdateQueryGenerator{},\n    )\n}\nResult:\nUser → app_users\nProduct → app_products","3-table-suffix#3. Table Suffix":"Add a suffix to table names (e.g., for table partitioning):\ntype SuffixedNamingStrategy struct {\n    Suffix string\n}\nfunc (s SuffixedNamingStrategy) GetTableNameFromStructName(structName string) string {\n    return toSnakeCase(structName) + \"s\" + s.Suffix\n}\nfunc (s SuffixedNamingStrategy) GetColumnNameFromStructName(fieldName string) string {\n    return toSnakeCase(fieldName)\n}\n// Usage\nfunc init() {\n    golightning.Register[User](\n        SuffixedNamingStrategy{Suffix: \"_2024\"},\n        lpg.PgInsertUpdateQueryGenerator{},\n    )\n}\nResult:\nUser → users_2024\nOrder → orders_2024","4-smart-pluralization#4. Smart Pluralization":"Implement proper English pluralization rules:\ntype SmartPluralNamingStrategy struct{}\nfunc (SmartPluralNamingStrategy) GetTableNameFromStructName(structName string) string {\n    snake := toSnakeCase(structName)\n    return pluralize(snake)\n}\nfunc (SmartPluralNamingStrategy) GetColumnNameFromStructName(fieldName string) string {\n    return toSnakeCase(fieldName)\n}\nfunc pluralize(word string) string {\n    // Simple pluralization rules (expand as needed)\n    if strings.HasSuffix(word, \"y\") {\n        return word[:len(word)-1] + \"ies\"  // category → categories\n    }\n    if strings.HasSuffix(word, \"s\") || strings.HasSuffix(word, \"x\") {\n        return word + \"es\"  // class → classes, box → boxes\n    }\n    return word + \"s\"\n}\nResult:\nCategory → categories (not categorys)\nClass → classes (not classs)\nBox → boxes (not boxs)","5-custom-column-prefix#5. Custom Column Prefix":"Prefix all column names:\ntype ColumnPrefixNamingStrategy struct {\n    ColumnPrefix string\n}\nfunc (s ColumnPrefixNamingStrategy) GetTableNameFromStructName(structName string) string {\n    return toSnakeCase(structName) + \"s\"\n}\nfunc (s ColumnPrefixNamingStrategy) GetColumnNameFromStructName(fieldName string) string {\n    return s.ColumnPrefix + toSnakeCase(fieldName)\n}\n// Usage\nfunc init() {\n    golightning.Register[User](\n        ColumnPrefixNamingStrategy{ColumnPrefix: \"user_\"},\n        lpg.PgInsertUpdateQueryGenerator{},\n    )\n}\nResult:\nField Id → Column user_id\nField Name → Column user_name\nField Email → Column user_email","6-exact-match-no-conversion#6. Exact Match (No Conversion)":"Use exact struct/field names without conversion:\ntype ExactNamingStrategy struct{}\nfunc (ExactNamingStrategy) GetTableNameFromStructName(structName string) string {\n    return structName  // No conversion\n}\nfunc (ExactNamingStrategy) GetColumnNameFromStructName(fieldName string) string {\n    return fieldName  // No conversion\n}\nResult:\nUserProfile → UserProfile table (exact match)\nFirstName → FirstName column (exact match)\nUse when:\nYour database uses CamelCase naming\nLegacy database with mixed conventions","overriding-default-strategy#Overriding Default Strategy":"","for-all-registrations-global#For All Registrations (Global)":"Modify the package-level variable:\nimport \"github.com/tracewayapp/go-lightning/lpg\"\nfunc init() {\n    // Override global naming strategy\n    lpg.NamingStrategy = PrefixedNamingStrategy{Prefix: \"app_\"}\n    // All subsequent registrations use new strategy\n    lpg.Register[User]()\n    lpg.Register[Product]()\n}","for-single-registration-per-type#For Single Registration (Per-Type)":"Use the core Register function with custom strategy:\nimport golightning \"github.com/tracewayapp/go-lightning\"\nimport \"github.com/tracewayapp/go-lightning/lpg\"\nfunc init() {\n    // User with custom strategy\n    golightning.Register[User](\n        PrefixedNamingStrategy{Prefix: \"app_\"},\n        lpg.PgInsertUpdateQueryGenerator{},\n    )\n    // Product with default strategy\n    lpg.Register[Product]()\n}","complete-example#Complete Example":"Here's a full example with a custom naming strategy:\npackage models\nimport (\n    \"strings\"\n    \"unicode\"\n    golightning \"github.com/tracewayapp/go-lightning\"\n    \"github.com/tracewayapp/go-lightning/lpg\"\n)\n// Custom strategy: prefix tables with \"tbl_\" and pluralize properly\ntype CustomNamingStrategy struct{}\nfunc (CustomNamingStrategy) GetTableNameFromStructName(structName string) string {\n    snake := toSnakeCase(structName)\n    plural := smartPluralize(snake)\n    return \"tbl_\" + plural\n}\nfunc (CustomNamingStrategy) GetColumnNameFromStructName(fieldName string) string {\n    return toSnakeCase(fieldName)\n}\nfunc toSnakeCase(s string) string {\n    var result []rune\n    for i, r := range s {\n        if unicode.IsUpper(r) {\n            if i > 0 {\n                result = append(result, '_')\n            }\n            result = append(result, unicode.ToLower(r))\n        } else {\n            result = append(result, r)\n        }\n    }\n    return string(result)\n}\nfunc smartPluralize(word string) string {\n    if strings.HasSuffix(word, \"y\") {\n        return word[:len(word)-1] + \"ies\"\n    }\n    if strings.HasSuffix(word, \"s\") || strings.HasSuffix(word, \"x\") {\n        return word + \"es\"\n    }\n    return word + \"s\"\n}\n// User struct\ntype User struct {\n    Id        int\n    FirstName string\n    LastName  string\n}\nfunc init() {\n    // Register with custom strategy\n    golightning.Register[User](\n        CustomNamingStrategy{},\n        lpg.PgInsertUpdateQueryGenerator{},\n    )\n}\n// Result:\n// Table: tbl_users\n// Columns: id, first_name, last_name\nSchema:\nCREATE TABLE tbl_users (\n    id SERIAL PRIMARY KEY,\n    first_name TEXT NOT NULL,\n    last_name TEXT NOT NULL\n);","testing-your-strategy#Testing Your Strategy":"Verify your naming strategy with a simple test:\npackage models\nimport (\n    \"reflect\"\n    \"testing\"\n    golightning \"github.com/tracewayapp/go-lightning\"\n)\nfunc TestNamingStrategy(t *testing.T) {\n    userType := reflect.TypeOf(User{})\n    fieldMap, err := golightning.GetFieldMap(userType)\n    if err != nil {\n        t.Fatal(err)\n    }\n    // Check table name\n    expectedTable := \"tbl_users\"\n    if fieldMap.TableName != expectedTable {\n        t.Errorf(\"Expected table %s, got %s\", expectedTable, fieldMap.TableName)\n    }\n    // Check column names\n    expectedColumns := []string{\"id\", \"first_name\", \"last_name\"}\n    if !reflect.DeepEqual(fieldMap.ColumnKeys, expectedColumns) {\n        t.Errorf(\"Expected columns %v, got %v\", expectedColumns, fieldMap.ColumnKeys)\n    }\n}","common-pitfalls#Common Pitfalls":"","1-inconsistent-casing#1. Inconsistent Casing":"// ❌ Database has mixed case but strategy uses lowercase\nCREATE TABLE Users (Id INT, FirstName TEXT)  -- Mixed case in DB\n// Strategy converts to lowercase\ntype User struct { Id int; FirstName string }\n// Results in \"users\" and \"first_name\" → mismatch!\n// ✅ Use ExactNamingStrategy or match DB conventions","2-special-characters#2. Special Characters":"// ❌ Don't use special chars in struct names\ntype User_Profile struct { /* ... */ }  // Underscore in name\n// ✅ Use CamelCase\ntype UserProfile struct { /* ... */ }","3-changing-strategy-after-registration#3. Changing Strategy After Registration":"// ❌ Can't change strategy after registration\nfunc init() {\n    lpg.Register[User]()  // Uses default strategy\n    lpg.NamingStrategy = CustomStrategy{}  // Too late!\n}\n// ✅ Set strategy before registration\nfunc init() {\n    lpg.NamingStrategy = CustomStrategy{}\n    lpg.Register[User]()  // Uses custom strategy\n}","summary#Summary":"Strategy Type\tTable Example\tColumn Example\tUse Case\tDefault\tusers\tfirst_name\tStandard Go → SQL\tNo Plural\tuser\tfirst_name\tSingular table names\tPrefixed\tapp_users\tfirst_name\tMulti-tenant schemas\tSuffixed\tusers_2024\tfirst_name\tPartitioned tables\tSmart Plural\tcategories\tfirst_name\tProper English rules\tExact\tUser\tFirstName\tCamelCase databases","best-practices#Best Practices":"Choose one strategy and use it consistently across your project\nSet global strategy early in init() before any registrations\nDocument your strategy so team members understand the mapping\nTest your strategy to verify it matches your database schema\nKeep it simple - complex strategies are harder to debug","next-steps#Next Steps":"Registration System - How registration uses naming strategies\nCore Concepts - Architecture overview\nAPI Reference - DbNamingStrategy interface documentation"}},"/guides/transactions":{"title":"Transactions","data":{"":"A comprehensive guide to working with database transactions in go-lightning.","why-transactions#Why Transactions?":"All go-lightning operations require a *sql.Tx (transaction) parameter, not *sql.DB. This design choice provides:\nExplicit control - You decide when to commit or rollback\nConsistency - Multiple operations execute as a single atomic unit\nIsolation - Changes are isolated until committed\nSafety - Automatic rollback on errors using defer","basic-transaction-pattern#Basic Transaction Pattern":"The recommended pattern for transactions:\n// Begin transaction\ntx, err := db.Begin()\nif err != nil {\n    return err\n}\ndefer tx.Rollback()  // Rollback if not committed\n// Perform database operations\nid, err := lpg.InsertGeneric(tx, &user)\nif err != nil {\n    return err  // Automatic rollback via defer\n}\n// More operations...\nuser, err := lpg.SelectGenericSingle[User](tx, \"SELECT * FROM users WHERE id = $1\", id)\nif err != nil {\n    return err\n}\n// Commit transaction\nif err := tx.Commit(); err != nil {\n    return err\n}\n// Success - changes are persisted\nreturn nil","the-deferred-rollback-pattern#The Deferred Rollback Pattern":"","why-defer-txrollback#Why defer tx.Rollback()?":"defer tx.Rollback()\nThis line ensures cleanup regardless of how the function exits:Safe behavior:\nIf Commit() succeeds → Rollback() is a no-op (does nothing)\nIf error occurs → Rollback() reverts changes\nIf function panics → Rollback() still executes\nWithout defer:\n// ❌ Don't do this\ntx, _ := db.Begin()\nid, err := lpg.InsertGeneric(tx, &user)\nif err != nil {\n    tx.Rollback()  // Must remember every time\n    return err\n}\n// More operations...\nerr = lpg.UpdateGeneric(tx, user, \"id = $1\", id)\nif err != nil {\n    tx.Rollback()  // Easy to forget!\n    return err\n}\ntx.Commit()\nWith defer:\n// ✅ Always use defer\ntx, _ := db.Begin()\ndefer tx.Rollback()  // One line, always executes\nid, err := lpg.InsertGeneric(tx, &user)\nif err != nil {\n    return err  // Rollback happens automatically\n}\n// ... more operations ...\ntx.Commit()  // If reached, rollback is no-op","transaction-isolation-levels#Transaction Isolation Levels":"Control how transactions interact with each other:","available-levels#Available Levels":"import \"database/sql\"\ntx, err := db.BeginTx(context.Background(), &sql.TxOptions{\n    Isolation: sql.LevelRepeatableRead,\n})\ndefer tx.Rollback()\nIsolation levels (from weakest to strongest):\nLevel\tDescription\tDirty Read\tNon-Repeatable Read\tPhantom Read\tLevelDefault\tDatabase default\tDepends\tDepends\tDepends\tLevelReadUncommitted\tCan see uncommitted changes\t✅\t✅\t✅\tLevelReadCommitted\tSee only committed changes\t❌\t✅\t✅\tLevelRepeatableRead\tConsistent reads within tx\t❌\t❌\t✅\tLevelSerializable\tFull isolation\t❌\t❌\t❌","database-defaults#Database Defaults":"PostgreSQL: ReadCommitted\nMySQL: RepeatableRead","when-to-use-each-level#When to Use Each Level":"ReadUncommitted (avoid):\nRarely used\nCan see dirty (uncommitted) data\nBest for read-heavy reporting where exact accuracy isn't critical\nReadCommitted (PostgreSQL default):\ntx, _ := db.BeginTx(ctx, &sql.TxOptions{\n    Isolation: sql.LevelReadCommitted,\n})\nGood for most applications\nPrevents dirty reads\nAllows concurrent updates\nRepeatableRead (MySQL default):\ntx, _ := db.BeginTx(ctx, &sql.TxOptions{\n    Isolation: sql.LevelRepeatableRead,\n})\nStronger consistency\nSame query returns same results within transaction\nPrevents non-repeatable reads\nSerializable (strongest):\ntx, _ := db.BeginTx(ctx, &sql.TxOptions{\n    Isolation: sql.LevelSerializable,\n})\nFull isolation\nTransactions execute as if serial (one at a time)\nPrevents phantom reads\nSlowest - use sparingly","read-only-transactions#Read-Only Transactions":"Optimize for read-only workloads:\ntx, err := db.BeginTx(context.Background(), &sql.TxOptions{\n    ReadOnly: true,\n})\ndefer tx.Rollback()\n// Only SELECT operations\nusers, err := lpg.SelectGeneric[User](tx, \"SELECT * FROM users\")\n// INSERT/UPDATE/DELETE will fail\n// id, err := lpg.InsertGeneric(tx, &user)  // Error!\ntx.Commit()\nBenefits:\nDatabase can optimize (no locking needed)\nPrevents accidental writes\nSlightly faster for large reads","context-and-timeouts#Context and Timeouts":"Use context for timeouts and cancellation:","with-timeout#With Timeout":"ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\ndefer cancel()\ntx, err := db.BeginTx(ctx, nil)\nif err != nil {\n    return err\n}\ndefer tx.Rollback()\n// Operations must complete within 5 seconds\nusers, err := lpg.SelectGeneric[User](tx, \"SELECT * FROM users\")\nif err != nil {\n    return err  // Could be timeout error\n}\ntx.Commit()","with-cancellation#With Cancellation":"ctx, cancel := context.WithCancel(context.Background())\n// Cancel from another goroutine if needed\ngo func() {\n    <-stopChan\n    cancel()  // Cancels transaction\n}()\ntx, err := db.BeginTx(ctx, nil)\ndefer tx.Rollback()\n// Operations...","multiple-operations-in-one-transaction#Multiple Operations in One Transaction":"Transactions ensure atomicity across multiple operations:","example-transfer-money#Example: Transfer Money":"func TransferMoney(db *sql.DB, fromUserID, toUserID int, amount float64) error {\n    tx, err := db.Begin()\n    if err != nil {\n        return err\n    }\n    defer tx.Rollback()\n    // Deduct from sender\n    err = lpg.Update(tx,\n        \"UPDATE accounts SET balance = balance - $1 WHERE user_id = $2\",\n        amount, fromUserID)\n    if err != nil {\n        return err  // Automatic rollback\n    }\n    // Add to receiver\n    err = lpg.Update(tx,\n        \"UPDATE accounts SET balance = balance + $1 WHERE user_id = $2\",\n        amount, toUserID)\n    if err != nil {\n        return err  // Automatic rollback - sender amount restored\n    }\n    // Both operations succeed or both fail\n    return tx.Commit()\n}","example-create-user-with-profile#Example: Create User with Profile":"func CreateUserWithProfile(db *sql.DB, user *User, profile *Profile) error {\n    tx, err := db.Begin()\n    if err != nil {\n        return err\n    }\n    defer tx.Rollback()\n    // Insert user\n    userID, err := lpg.InsertGeneric(tx, user)\n    if err != nil {\n        return err\n    }\n    // Insert profile with user's ID\n    profile.UserID = userID\n    _, err = lpg.InsertGeneric(tx, profile)\n    if err != nil {\n        return err  // User insert is rolled back too\n    }\n    return tx.Commit()\n}","nested-transactions-savepoints#Nested Transactions (Savepoints)":"Go's database/sql doesn't support nested transactions, but you can use savepoints:","postgresql-savepoints#PostgreSQL Savepoints":"tx, _ := db.Begin()\ndefer tx.Rollback()\n// Create savepoint\n_, err := tx.Exec(\"SAVEPOINT sp1\")\nif err != nil {\n    return err\n}\n// Some operations\nid, err := lpg.InsertGeneric(tx, &user)\nif err != nil {\n    // Rollback to savepoint (partial rollback)\n    tx.Exec(\"ROLLBACK TO SAVEPOINT sp1\")\n} else {\n    // Release savepoint\n    tx.Exec(\"RELEASE SAVEPOINT sp1\")\n}\n// Continue with other operations\n// ...\ntx.Commit()","mysql-savepoints#MySQL Savepoints":"Same syntax works in MySQL:\ntx, _ := db.Begin()\ndefer tx.Rollback()\ntx.Exec(\"SAVEPOINT sp1\")\n// Operations...\nif err != nil {\n    tx.Exec(\"ROLLBACK TO SAVEPOINT sp1\")\n}\ntx.Commit()","connection-pooling#Connection Pooling":"Transactions use connections from the pool:\n// Configure pool\ndb.SetMaxOpenConns(25)       // Max connections\ndb.SetMaxIdleConns(5)        // Idle connections kept open\ndb.SetConnMaxLifetime(5 * time.Minute)  // Max connection age\nImportant:\nEach transaction holds a connection until committed or rolled back\nLong-running transactions block other operations\nAlways commit or rollback promptly","pool-exhaustion#Pool Exhaustion":"// ❌ Bad: Holds connection indefinitely\ntx, _ := db.Begin()\ntime.Sleep(10 * time.Minute)  // Connection stuck!\ntx.Commit()\n// ✅ Good: Quick transaction\ntx, _ := db.Begin()\ndefer tx.Rollback()\nlpg.InsertGeneric(tx, &user)\ntx.Commit()  // Connection returned to pool","error-handling-patterns#Error Handling Patterns":"","basic-error-handling#Basic Error Handling":"tx, err := db.Begin()\nif err != nil {\n    return fmt.Errorf(\"begin tx: %w\", err)\n}\ndefer tx.Rollback()\nid, err := lpg.InsertGeneric(tx, &user)\nif err != nil {\n    return fmt.Errorf(\"insert user: %w\", err)\n}\nif err := tx.Commit(); err != nil {\n    return fmt.Errorf(\"commit tx: %w\", err)\n}\nreturn nil","with-logging#With Logging":"import \"log\"\ntx, err := db.Begin()\nif err != nil {\n    log.Printf(\"Failed to begin transaction: %v\", err)\n    return err\n}\ndefer func() {\n    if err := tx.Rollback(); err != nil && err != sql.ErrTxDone {\n        log.Printf(\"Rollback failed: %v\", err)\n    }\n}()\n// Operations...","with-custom-errors#With Custom Errors":"var (\n    ErrUserExists = errors.New(\"user already exists\")\n    ErrInvalidData = errors.New(\"invalid data\")\n)\nfunc CreateUser(db *sql.DB, user *User) error {\n    tx, err := db.Begin()\n    if err != nil {\n        return err\n    }\n    defer tx.Rollback()\n    // Check if user exists\n    existing, _ := lpg.SelectGenericSingle[User](tx,\n        \"SELECT * FROM users WHERE email = $1\", user.Email)\n    if existing != nil {\n        return ErrUserExists  // Rollback via defer\n    }\n    // Validate\n    if user.Email == \"\" {\n        return ErrInvalidData  // Rollback via defer\n    }\n    // Insert\n    _, err = lpg.InsertGeneric(tx, user)\n    if err != nil {\n        return err\n    }\n    return tx.Commit()\n}","best-practices#Best Practices":"","1-always-use-defer-txrollback#1. Always Use defer tx.Rollback()":"// ✅ Always\ntx, _ := db.Begin()\ndefer tx.Rollback()","2-keep-transactions-short#2. Keep Transactions Short":"// ❌ Bad: Long-running transaction\ntx, _ := db.Begin()\ndefer tx.Rollback()\nfor i := 0; i < 10000; i++ {\n    lpg.InsertGeneric(tx, &records[i])  // Holds connection too long\n}\ntx.Commit()\n// ✅ Good: Batch commits\nfor i := 0; i < len(records); i += 100 {\n    tx, _ := db.Begin()\n    for j := i; j < i+100 && j < len(records); j++ {\n        lpg.InsertGeneric(tx, &records[j])\n    }\n    tx.Commit()  // Release connection every 100 records\n}","3-dont-perform-io-inside-transactions#3. Don't Perform I/O Inside Transactions":"// ❌ Bad: Network call during transaction\ntx, _ := db.Begin()\ndefer tx.Rollback()\nuser, _ := lpg.SelectGenericSingle[User](tx, \"SELECT * FROM users WHERE id = $1\", id)\n// HTTP call while holding transaction!\nresp, _ := http.Get(\"https://api.example.com/validate\")  // Bad!\ntx.Commit()\n// ✅ Good: I/O outside transaction\nuser, _ := lpg.SelectGenericSingle[User](tx, \"SELECT * FROM users WHERE id = $1\", id)\ntx.Commit()  // Done with DB\n// Now do I/O\nresp, _ := http.Get(\"https://api.example.com/validate\")","4-use-appropriate-isolation-levels#4. Use Appropriate Isolation Levels":"// For reports (read-only, no exact consistency needed)\ntx, _ := db.BeginTx(ctx, &sql.TxOptions{\n    Isolation: sql.LevelReadCommitted,\n    ReadOnly:  true,\n})\n// For financial transactions (strict consistency)\ntx, _ := db.BeginTx(ctx, &sql.TxOptions{\n    Isolation: sql.LevelSerializable,\n})","5-add-timeouts#5. Add Timeouts":"// ✅ Always set a timeout\nctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\ndefer cancel()\ntx, _ := db.BeginTx(ctx, nil)","troubleshooting#Troubleshooting":"","sql-transaction-has-already-been-committed-or-rolled-back#\"sql: transaction has already been committed or rolled back\"":"Cause: Trying to use transaction after commit/rollback\n// ❌ Bad\ntx, _ := db.Begin()\ntx.Commit()\nlpg.InsertGeneric(tx, &user)  // Error!","pq-deadlock-detected#\"pq: deadlock detected\"":"Cause: Two transactions waiting for each otherSolution:\nAccess tables in same order\nUse lower isolation levels\nKeep transactions short","too-many-connections#\"too many connections\"":"Cause: Transactions not being closedSolution:\n// ✅ Always use defer\ndefer tx.Rollback()","summary#Summary":"Pattern\tCode\tUse Case\tBasic\tdefer tx.Rollback()\tAll transactions\tRead-Only\tReadOnly: true\tSELECT-only operations\tTimeout\tWithTimeout(ctx, 30*time.Second)\tPrevent hung transactions\tIsolation\tIsolation: LevelSerializable\tCritical consistency needs\tSavepoint\tSAVEPOINT sp1\tPartial rollbacks","next-steps#Next Steps":"PostgreSQL Guide - PostgreSQL-specific transaction features\nMySQL Guide - MySQL-specific transaction features\nExamples - See transactions in action"}},"/examples/basic-crud":{"title":"Basic CRUD Example","data":{"":"A simple, complete example demonstrating all CRUD operations with go-lightning.","complete-code#Complete Code":"package main\nimport (\n    \"database/sql\"\n    \"fmt\"\n    \"log\"\n    _ \"github.com/jackc/pgx/v5/stdlib\"\n    \"github.com/tracewayapp/go-lightning/lpg\"\n)\n// User model\ntype User struct {\n    Id        int\n    FirstName string\n    LastName  string\n    Email     string\n}\n// Register the type\nfunc init() {\n    lpg.Register[User]()\n}\nfunc main() {\n    // Connect to database\n    db, err := sql.Open(\"pgx\", \"postgres://user:password@localhost:5432/dbname?sslmode=disable\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer db.Close()\n    // Begin transaction\n    tx, err := db.Begin()\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer tx.Rollback()\n    // CREATE\n    user := &User{\n        FirstName: \"John\",\n        LastName:  \"Doe\",\n        Email:     \"john.doe@example.com\",\n    }\n    id, err := lpg.InsertGeneric(tx, user)\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Printf(\"Created user with ID: %d\\n\", id)\n    // READ (single)\n    foundUser, err := lpg.SelectGenericSingle[User](tx,\n        \"SELECT * FROM users WHERE id = $1\", id)\n    if err != nil {\n        log.Fatal(err)\n    }\n    if foundUser != nil {\n        fmt.Printf(\"Found: %s %s\\n\", foundUser.FirstName, foundUser.LastName)\n    }\n    // READ (multiple)\n    users, err := lpg.SelectGeneric[User](tx,\n        \"SELECT * FROM users LIMIT 10\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Printf(\"Total users: %d\\n\", len(users))\n    // UPDATE\n    foundUser.FirstName = \"Jane\"\n    err = lpg.UpdateGeneric(tx, foundUser, \"id = $1\", id)\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Println(\"Updated user\")\n    // DELETE\n    err = lpg.Delete(tx, \"DELETE FROM users WHERE id = $1\", id)\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Println(\"Deleted user\")\n    // Commit\n    if err := tx.Commit(); err != nil {\n        log.Fatal(err)\n    }\n    fmt.Println(\"Success!\")\n}","database-schema#Database Schema":"CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    first_name TEXT NOT NULL,\n    last_name TEXT NOT NULL,\n    email TEXT UNIQUE NOT NULL\n);","running-the-example#Running the Example":"# Install dependencies\ngo get github.com/tracewayapp/go-lightning/lpg\ngo get github.com/jackc/pgx/v5/stdlib\n# Create the database table\npsql -U user -d dbname < schema.sql\n# Run the example\ngo run main.go","output#Output":"Created user with ID: 1\nFound: John Doe\nTotal users: 1\nUpdated user\nDeleted user\nSuccess!","next-steps#Next Steps":"PostgreSQL Complete Example - Full example with error handling\nMySQL Complete Example - MySQL version\nUUID Entities - Using UUID primary keys"}},"/troubleshooting/common-errors":{"title":"Common Errors","data":{"":"Solutions to frequently encountered errors.","non-registered-model-x-used#\"Non registered model X used\"":"Error Message:\nNon registered model User used. Please call `var _ = Register[User]()` after you define User\nCause: Type was never registered with Register[T]().Solution:\nfunc init() {\n    lpg.Register[User]()  // Add this\n}","invalid-column-that-is-not-found-in-the-struct#\"invalid column that is not found in the struct\"":"Error Message:\ninvalid column that is not found in the struct created_at\nCause: SELECT query returns columns not in your struct.Solutions:\nOnly select columns that exist:\n// ❌ Bad\nusers, err := lpg.SelectGeneric[User](tx, \"SELECT *, created_at FROM users\")\n// ✅ Good\nusers, err := lpg.SelectGeneric[User](tx, \"SELECT id, name, email FROM users\")\nAdd field to struct:\ntype User struct {\n    Id        int\n    Name      string\n    CreatedAt time.Time  // Add this\n}","parameter-where-was-not-present#\"parameter 'where' was not present\"":"Error Message:\nparameter 'where' was not present\nCause: Empty WHERE clause in UpdateGeneric.Solution:\n// ❌ Bad\nlpg.UpdateGeneric(tx, user, \"\", nil)\n// ✅ Good\nlpg.UpdateGeneric(tx, user, \"id = $1\", user.Id)","parameter-mismatch-errors#Parameter Mismatch Errors":"PostgreSQL - \"bind message supplies X parameters, but prepared statement requires Y\"Cause: Wrong number of arguments for placeholders.Solution:\n// ❌ Bad: 2 placeholders, 1 argument\nlpg.SelectGeneric[User](tx, \"SELECT * FROM users WHERE id = $1 AND active = $2\", userId)\n// ✅ Good: 2 placeholders, 2 arguments\nlpg.SelectGeneric[User](tx, \"SELECT * FROM users WHERE id = $1 AND active = $2\", userId, true)","sql-transaction-has-already-been-committed-or-rolled-back#\"sql: transaction has already been committed or rolled back\"":"Cause: Using transaction after commit/rollback.Solution:\ntx, _ := db.Begin()\ndefer tx.Rollback()\nlpg.InsertGeneric(tx, &user)\ntx.Commit()\n// ❌ Don't use tx after commit\n// lpg.SelectGeneric[User](tx, query)  // Error!\n// ✅ Create new transaction\ntx2, _ := db.Begin()\ndefer tx2.Rollback()\nlpg.SelectGeneric[User](tx2, query)\ntx2.Commit()","too-many-clients-already-postgresql#\"too many clients already\" (PostgreSQL)":"Cause: Connection pool exhausted.Solutions:\nReduce max connections:\ndb.SetMaxOpenConns(10)\nEnsure transactions are closed:\n// ✅ Always use defer\ntx, _ := db.Begin()\ndefer tx.Rollback()","parsetime-parameter-must-be-set-to-true-mysql#\"parseTime parameter must be set to true\" (MySQL)":"Cause: Missing parseTime=true in connection string.Solution:\n// ❌ Bad\n\"user:pass@tcp(localhost:3306)/db\"\n// ✅ Good\n\"user:pass@tcp(localhost:3306)/db?parseTime=true\"\nSee Debugging Guide for more help."}},"/getting-started/quick-start":{"title":"Quick Start","data":{"":"This guide will walk you through creating your first application with go-lightning in just a few minutes.","prerequisites#Prerequisites":"Go 1.25.1 or higher installed\nPostgreSQL or MySQL database running\nBasic familiarity with Go and SQL","step-1-install-go-lightning#Step 1: Install go-lightning":"For PostgreSQL:\ngo get github.com/tracewayapp/go-lightning/lpg\ngo get github.com/jackc/pgx/v5/stdlib\nFor MySQL:\ngo get github.com/tracewayapp/go-lightning/lmy\ngo get github.com/go-sql-driver/mysql\nThis guide uses PostgreSQL, but the process is similar for MySQL.","step-2-create-your-database-table#Step 2: Create Your Database Table":"Create a users table in your PostgreSQL database:\nCREATE TABLE IF NOT EXISTS users (\n    id SERIAL PRIMARY KEY,\n    first_name TEXT NOT NULL,\n    last_name TEXT NOT NULL,\n    email TEXT UNIQUE NOT NULL\n);","step-3-define-your-struct#Step 3: Define Your Struct":"Create a models directory and define your User struct:models/user.go\npackage models\nimport \"github.com/tracewayapp/go-lightning/lpg\"\ntype User struct {\n    Id        int\n    FirstName string\n    LastName  string\n    Email     string\n}\nfunc init() {\n    lpg.Register[User]()  // Register the type for generic operations\n}","important-notes#Important Notes:":"Field names follow Go naming conventions (CamelCase)\ngo-lightning automatically maps FirstName → first_name, User → users\ninit() function registers the type when the package is imported\nThe Id field (int type) is automatically handled for auto-increment","step-4-write-your-application#Step 4: Write Your Application":"main.go\npackage main\nimport (\n    \"database/sql\"\n    \"fmt\"\n    \"log\"\n    _ \"github.com/jackc/pgx/v5/stdlib\"\n    \"github.com/tracewayapp/go-lightning/lpg\"\n    \"yourproject/models\"  // This triggers init() and registration\n)\nfunc main() {\n    // Connect to database\n    db, err := sql.Open(\"pgx\", \"postgres://user:password@localhost:5432/dbname?sslmode=disable\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer db.Close()\n    // Begin transaction\n    tx, err := db.Begin()\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer tx.Rollback()  // Rollback if not committed\n    // CREATE: Insert a new user\n    newUser := &models.User{\n        FirstName: \"John\",\n        LastName:  \"Doe\",\n        Email:     \"john.doe@example.com\",\n    }\n    id, err := lpg.InsertGeneric(tx, newUser)\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Printf(\"Inserted user with ID: %d\\n\", id)\n    // READ: Select a single user\n    user, err := lpg.SelectGenericSingle[models.User](tx,\n        \"SELECT * FROM users WHERE id = $1\", id)\n    if err != nil {\n        log.Fatal(err)\n    }\n    if user != nil {\n        fmt.Printf(\"Found user: %s %s (%s)\\n\",\n            user.FirstName, user.LastName, user.Email)\n    }\n    // READ: Select multiple users\n    users, err := lpg.SelectGeneric[models.User](tx,\n        \"SELECT * FROM users LIMIT 10\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Printf(\"Found %d users\\n\", len(users))\n    for _, u := range users {\n        fmt.Printf(\" - %d: %s %s\\n\", u.Id, u.FirstName, u.LastName)\n    }\n    // UPDATE: Modify a user\n    user.FirstName = \"Jane\"\n    err = lpg.UpdateGeneric(tx, user, \"id = $1\", user.Id)\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Println(\"Updated user name to Jane\")\n    // DELETE: Remove a user\n    err = lpg.Delete(tx, \"DELETE FROM users WHERE id = $1\", id)\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Printf(\"Deleted user %d\\n\", id)\n    // Commit transaction\n    if err := tx.Commit(); err != nil {\n        log.Fatal(err)\n    }\n    fmt.Println(\"CRUD operations completed successfully!\")\n}","step-5-run-your-application#Step 5: Run Your Application":"go run main.go\nYou should see output similar to:\nInserted user with ID: 1\nFound user: John Doe (john.doe@example.com)\nFound 1 users\n - 1: John Doe\nUpdated user name to Jane\nDeleted user 1\nCRUD operations completed successfully!","what-just-happened#What Just Happened?":"Let's break down the key parts:","1-registration#1. Registration":"func init() {\n    lpg.Register[User]()\n}\nThis builds metadata about your User struct:\nMaps FirstName → first_name column\nMaps User → users table\nDetects Id as auto-increment field\nPre-builds INSERT and UPDATE queries","2-insertgeneric#2. InsertGeneric":"id, err := lpg.InsertGeneric(tx, newUser)\nExecutes: INSERT INTO users (first_name, last_name, email) VALUES ($1, $2, $3) RETURNING idThe Id field is excluded because it's auto-increment.","3-selectgenericsingle#3. SelectGenericSingle":"user, err := lpg.SelectGenericSingle[models.User](tx,\n    \"SELECT * FROM users WHERE id = $1\", id)\nExecutes your SQL query\nAutomatically scans columns into struct fields\nReturns nil, nil (not error) if no rows found","4-selectgeneric#4. SelectGeneric":"users, err := lpg.SelectGeneric[models.User](tx,\n    \"SELECT * FROM users LIMIT 10\")\nReturns a slice of pointers: []*User\nEmpty slice (not nil) if no results\nAll struct fields must match returned columns","5-updategeneric#5. UpdateGeneric":"err = lpg.UpdateGeneric(tx, user, \"id = $1\", user.Id)\nExecutes: UPDATE users SET first_name = $1, last_name = $2, email = $3 WHERE id = $4Important: Updates ALL fields in the struct. WHERE clause is required.","6-delete#6. Delete":"err = lpg.Delete(tx, \"DELETE FROM users WHERE id = $1\", id)\nSimple wrapper for DELETE queries. Not generic-specific.","mysql-version#MySQL Version":"The process is nearly identical for MySQL. Just change the imports and connection:\nimport (\n    _ \"github.com/go-sql-driver/mysql\"\n    \"github.com/tracewayapp/go-lightning/lmy\"\n    \"yourproject/models\"\n)\n// Register in models/user.go\nfunc init() {\n    lmy.Register[User]()\n}\n// Connection string\ndb, err := sql.Open(\"mysql\", \"user:password@tcp(localhost:3306)/dbname?parseTime=true\")\n// Query placeholders use ? instead of $1\nuser, err := lmy.SelectGenericSingle[models.User](tx,\n    \"SELECT * FROM users WHERE id = ?\", id)","common-first-time-mistakes#Common First-Time Mistakes":"","1-forgot-to-register#1. Forgot to Register":"// ❌ This will panic\nid, err := lpg.InsertGeneric(tx, &user)  // Error: non-registered model\n// ✅ Always register first\nfunc init() {\n    lpg.Register[User]()\n}","2-column-mismatch#2. Column Mismatch":"// ❌ SELECT returns columns not in struct\nusers, err := lpg.SelectGeneric[models.User](tx,\n    \"SELECT *, created_at FROM users\")  // Panic: invalid column 'created_at'\n// ✅ Only select columns that exist in struct\nusers, err := lpg.SelectGeneric[models.User](tx,\n    \"SELECT id, first_name, last_name, email FROM users\")","3-empty-where-clause#3. Empty WHERE Clause":"// ❌ UpdateGeneric requires WHERE clause\nerr = lpg.UpdateGeneric(tx, user, \"\", nil)  // Error: where parameter not present\n// ✅ Always provide WHERE clause\nerr = lpg.UpdateGeneric(tx, user, \"id = $1\", user.Id)","4-using-sqldb-instead-of-sqltx#4. Using *sql.DB Instead of *sql.Tx":"// ❌ All operations require transactions\nid, err := lpg.InsertGeneric(db, &user)  // Won't compile\n// ✅ Use Begin() to create transaction\ntx, _ := db.Begin()\nid, err := lpg.InsertGeneric(tx, &user)\ntx.Commit()","next-steps#Next Steps":"Now that you've completed your first CRUD application:\nCore Concepts - Understand the registration system, naming strategies, and architecture\nPostgreSQL Guide - Learn about UUID support, parameter handling, and PostgreSQL-specific features\nMySQL Guide - Understand MySQL-specific behaviors\nAPI Reference - Complete API documentation\nExamples - More complete examples with error handling"}},"/troubleshooting/debugging":{"title":"Debugging Guide","data":{"":"Tips and techniques for debugging go-lightning applications.","inspecting-fieldmap#Inspecting FieldMap":"View registered metadata:\nimport (\n    \"reflect\"\n    \"fmt\"\n    golightning \"github.com/tracewayapp/go-lightning\"\n)\nuserType := reflect.TypeOf(User{})\nfieldMap, err := golightning.GetFieldMap(userType)\nif err != nil {\n    log.Fatal(\"Not registered:\", err)\n}\nfmt.Println(\"Table:\", fieldMap.TableName)\nfmt.Println(\"Columns:\", fieldMap.ColumnKeys)\nfmt.Println(\"INSERT:\", fieldMap.InsertQuery)\nfmt.Println(\"UPDATE:\", fieldMap.UpdateQuery)","logging-queries#Logging Queries":"Enable SQL logging in your database driver:","postgresql-pgx#PostgreSQL (pgx)":"import (\n    \"github.com/jackc/pgx/v5\"\n    \"github.com/jackc/pgx/v5/tracelog\"\n)\nconfig, _ := pgx.ParseConfig(connString)\nconfig.Tracer = &tracelog.TraceLog{\n    Logger:   tracelog.LoggerFunc(func(ctx context.Context, level tracelog.LogLevel, msg string, data map[string]interface{}) {\n        log.Printf(\"[%s] %s %v\", level, msg, data)\n    }),\n    LogLevel: tracelog.LogLevelDebug,\n}","mysql#MySQL":"Set ?parseTime=true&loc=Local&interpolateParams=true for query interpolation.","common-debugging-steps#Common Debugging Steps":"Verify registration:\n// Check if type is registered\n_, err := golightning.GetFieldMap(reflect.TypeOf(User{}))\nif err != nil {\n    log.Println(\"User not registered!\")\n}\nCheck database schema:\n# PostgreSQL\npsql -d dbname -c \"\\d users\"\n# MySQL\nmysql -e \"DESCRIBE users\"\nValidate struct fields match columns:\nEnsure naming strategy produces correct names.\nTest with simple queries:\nStart with SELECT * before complex queries.\nEnable verbose error logging:\nif err != nil {\n    log.Printf(\"Error: %+v\\n\", err)  // Verbose error\n}\nSee Common Errors for specific issues."}},"/getting-started/introduction":{"title":"Introduction","data":{"what-is-go-lightning#What is go-lightning?":"go-lightning is a lightweight Go library for simplified database operations using generics. It provides type-safe wrappers around Go's standard database/sql package with automatic struct-to-table mapping, reducing boilerplate code for common CRUD operations.","philosophy#Philosophy":"go-lightning follows these design principles:","1-thin-abstraction-layer#1. Thin Abstraction Layer":"go-lightning is not an ORM. It's a convenience layer over database/sql that handles the repetitive parts (struct scanning, query templates) while keeping you in control of SQL queries and transaction management.","2-explicit-over-implicit#2. Explicit Over Implicit":"Explicit registration - Types must be registered before use with Register[T]()\nExplicit transactions - All operations require a *sql.Tx parameter\nExplicit SQL - You write the queries; go-lightning handles the mapping","3-type-safety#3. Type Safety":"Leveraging Go 1.18+ generics for compile-time type checking. Errors are caught at compile time, not runtime.","4-performance#4. Performance":"Reflection happens once at registration time to build query templates and field mappings. During execution, pre-built templates are used with zero reflection overhead.","why-use-go-lightning#Why Use go-lightning?":"","-use-go-lightning-when-you#✅ Use go-lightning when you:":"Want to reduce boilerplate code for basic CRUD operations\nNeed type-safe database operations with compile-time checking\nPrefer writing SQL but don't want manual struct scanning\nValue explicit control over transactions and queries\nWant automatic naming convention mapping (e.g., UserProfile → user_profiles)","-dont-use-go-lightning-when-you#❌ Don't use go-lightning when you:":"Need complex query building (use raw SQL or a query builder)\nWant automatic migrations or schema management (use a migration tool)\nPrefer active record patterns (use an ORM like GORM)\nNeed database-agnostic query generation (write database-specific queries)","architecture-overview#Architecture Overview":"","the-flow#The Flow":"1. Define Struct          →  type User struct { Id int; Name string }\n2. Register Type          →  lpg.Register[User]()\n3. FieldMap Created       →  (Reflection happens here, once)\n4. Use Generic Operations →  lpg.InsertGeneric(tx, &user)\n5. Fast Execution         →  (Pre-built templates, zero reflection)","key-components#Key Components":"","registration-system#Registration System":"Before using a struct type with generic operations, you must register it:\nfunc init() {\n    lpg.Register[User]()\n}\nThis builds a FieldMap containing:\nColumn name mappings (struct field → database column)\nPre-built INSERT/UPDATE query templates\nID field detection for special handling","naming-strategy#Naming Strategy":"The DbNamingStrategy interface converts Go naming to database naming:\nStruct names → Table names: UserProfile → user_profiles (snake_case + plural)\nField names → Column names: FirstName → first_name (snake_case)\nYou can provide custom strategies for different conventions.","generic-operations#Generic Operations":"Type-safe functions that automatically map between structs and database rows:\nlpg.SelectGeneric[User](tx, query, args...)      // Returns []*User\nlpg.InsertGeneric(tx, &user)                     // Returns int (ID)\nlpg.UpdateGeneric(tx, &user, where, args...)     // Updates all fields","manual-operations#Manual Operations":"For cases requiring custom mapping, use manual operations with a mapLine function:\nlpg.SelectMultiple[User](tx, mapLine, query, args...)","performance-characteristics#Performance Characteristics":"","registration-time-one-time-cost#Registration Time (One-Time Cost)":"Reflection: Inspects struct fields to build field map\nQuery Building: Generates INSERT and UPDATE query templates\nHappens: At init() time or first Register[] call","query-execution-runtime#Query Execution (Runtime)":"Zero Reflection: Uses pre-built templates and field indexes\nDirect Scanning: Pointers to struct fields are pre-calculated\nPerformance: Comparable to hand-written database/sql code","next-steps#Next Steps":"Installation - Install go-lightning for your database\nQuick Start - Build your first CRUD application\nCore Concepts - Deep dive into the architecture"}},"/getting-started/core-concepts":{"title":"Core Concepts","data":{"":"Understanding these core concepts will help you use go-lightning effectively.","registration-system#Registration System":"","why-registration-is-required#Why Registration is Required":"Before using a struct type with generic operations, you must register it with Register[T](). This is a one-time operation that builds metadata used for all subsequent database operations.\ntype User struct {\n    Id        int\n    FirstName string\n    LastName  string\n    Email     string\n}\nfunc init() {\n    lpg.Register[User]()  // Register during package initialization\n}","what-happens-during-registration#What Happens During Registration":"When you call Register[User](), go-lightning:\nInspects the struct using reflection to find all fields\nMaps field names to column names using the naming strategy\nDetects the ID field to enable special handling for auto-increment\nBuilds query templates for INSERT and UPDATE operations\nStores metadata in a global FieldMap for fast lookups","the-fieldmap-structure#The FieldMap Structure":"type FieldMap struct {\n    ColumnsMap    map[string]int  // column name → struct field index\n    ColumnKeys    []string         // all column names in order\n    HasIntId      bool             // true if Id field is int type\n    InsertQuery   string           // pre-built INSERT template\n    UpdateQuery   string           // pre-built UPDATE template\n    InsertColumns []string         // columns for INSERT (excludes auto-increment id)\n}\nExample for User struct:\nFieldMap{\n    ColumnsMap: {\n        \"id\": 0,\n        \"first_name\": 1,\n        \"last_name\": 2,\n        \"email\": 3,\n    },\n    ColumnKeys: [\"id\", \"first_name\", \"last_name\", \"email\"],\n    HasIntId: true,\n    InsertQuery: \"INSERT INTO users (first_name, last_name, email) VALUES ($1, $2, $3) RETURNING id\",\n    UpdateQuery: \"UPDATE users SET first_name = $1, last_name = $2, email = $3\",\n    InsertColumns: [\"first_name\", \"last_name\", \"email\"],\n}","when-to-register#When to Register":"Best Practice: Register in the init() function of the package that defines the struct:\n// models/user.go\npackage models\nimport \"github.com/tracewayapp/go-lightning/lpg\"\ntype User struct {\n    Id        int\n    FirstName string\n}\nfunc init() {\n    lpg.Register[User]()\n}\nWhy init()?\nRuns automatically when the package is imported\nHappens once, before main()\nNo risk of forgetting to register\nWhat if I forget to register?You'll get a helpful panic message:\nNon registered model User used. Please call `var _ = Register[User]()` after you define User","naming-strategies#Naming Strategies":"Naming strategies control how Go struct names map to database table and column names.","default-naming-strategy#Default Naming Strategy":"go-lightning uses DefaultDbNamingStrategy which follows these rules:","table-names#Table Names":"Convert struct name from CamelCase to snake_case\nAdd s suffix for pluralization\nExamples:\nUser → users\nUserProfile → user_profiles\nOrderHistory → order_historys (simple suffix, not smart pluralization)","column-names#Column Names":"Convert field name from CamelCase to snake_case\nExamples:\nId → id\nFirstName → first_name\nCreatedAt → created_at\nIsActive → is_active","dbnamingstrategy-interface#DbNamingStrategy Interface":"type DbNamingStrategy interface {\n    GetTableNameFromStructName(string) string\n    GetColumnNameFromStructName(string) string\n}","custom-naming-strategies#Custom Naming Strategies":"You can implement your own naming strategy for different conventions:\n// Example: Prefix all tables with \"app_\"\ntype PrefixedNamingStrategy struct {\n    prefix string\n}\nfunc (s PrefixedNamingStrategy) GetTableNameFromStructName(structName string) string {\n    tableName := toSnakeCase(structName)\n    return s.prefix + tableName + \"s\"\n}\nfunc (s PrefixedNamingStrategy) GetColumnNameFromStructName(fieldName string) string {\n    return toSnakeCase(fieldName)\n}\n// Usage\nlpg.Register[User](PrefixedNamingStrategy{prefix: \"app_\"}, lpg.PgInsertUpdateQueryGenerator{})\n// User → app_users\nFor more details, see Naming Strategies Guide.","id-field-handling#ID Field Handling":"go-lightning provides special handling for primary key Id fields based on their type.","integer-id-auto-increment#Integer ID (Auto-Increment)":"If your struct has an Id field of type int:\ntype User struct {\n    Id   int     // Auto-increment detected\n    Name string\n}\nBehavior:\nINSERT: Id field is excluded from the INSERT statement (database generates it)\nPostgreSQL: Uses RETURNING id clause to retrieve the generated ID\nMySQL: Uses LastInsertId() to retrieve the generated ID\nUPDATE: Id field is included (but typically not in SET clause)\nSQL Generated (PostgreSQL):\nINSERT INTO users (name) VALUES ($1) RETURNING id","string-id-uuid#String ID (UUID)":"If your struct has an Id field of type string:\ntype Entity struct {\n    Id          string  // UUID will be generated\n    Name        string\n    Description string\n}\nUse InsertGenericUuid:\nuuid, err := lpg.InsertGenericUuid(tx, &entity)\n// uuid is the generated UUID string\n// entity.Id is now set to the generated UUID\nOr use InsertGenericExistingUuid if you already have a UUID:\nentity.Id = uuid.New().String()  // Set UUID first\nerr := lpg.InsertGenericExistingUuid(tx, &entity)","no-id-field#No ID Field":"If your struct doesn't have an Id field, all fields are treated equally:\ntype ActivityLog struct {\n    Timestamp time.Time\n    Action    string\n    UserId    int\n}\nAll fields will be included in INSERT operations.","generic-vs-manual-operations#Generic vs Manual Operations":"go-lightning offers two approaches for database operations:","generic-operations#Generic Operations":"Automatic struct-to-row mapping. Requires registration.\n// Automatic mapping\nusers, err := lpg.SelectGeneric[User](tx, \"SELECT * FROM users\")\nPros:\nNo manual Scan() calls\nType-safe with compile-time checking\nLess boilerplate code\nCons:\nRequires registration\nAll SELECT columns must exist in struct\nLess flexible for complex queries\nUse when:\nStandard CRUD operations\nStruct fields match query columns\nYou want minimal boilerplate","manual-operations#Manual Operations":"Custom mapping function required. No registration needed.\nfunc mapUser(rows *sql.Rows, user *User) error {\n    return rows.Scan(&user.Id, &user.FirstName, &user.LastName)\n}\nusers, err := lpg.SelectMultiple[User](tx, mapUser, \"SELECT id, first_name, last_name FROM users\")\nPros:\nFull control over scanning\nCan select subset of columns\nCan map to different field names\nNo registration required\nCons:\nManual Scan() implementation\nMore boilerplate\nEasier to make mistakes\nUse when:\nComplex queries with joins\nSelecting only specific columns\nMapping to DTOs or view models\nAggregations and computed fields","transaction-based-operations#Transaction-Based Operations":"All go-lightning operations require a *sql.Tx (transaction) parameter, not *sql.DB.","why-transactions-only#Why Transactions Only?":"Explicit control - You decide when to commit or rollback\nConsistency - Multiple operations in one transaction\nSafety - Automatic rollback on errors if using defer","transaction-pattern#Transaction Pattern":"// Begin transaction\ntx, err := db.Begin()\nif err != nil {\n    return err\n}\ndefer tx.Rollback()  // Rollback if not committed\n// Perform operations\nid, err := lpg.InsertGeneric(tx, &user)\nif err != nil {\n    return err  // Rollback happens via defer\n}\n// Commit on success\nif err := tx.Commit(); err != nil {\n    return err\n}","deferred-rollback-pattern#Deferred Rollback Pattern":"The defer tx.Rollback() pattern is safe and recommended:\nIf Commit() succeeds, Rollback() is a no-op (does nothing)\nIf an error occurs before Commit(), changes are rolled back\nEnsures cleanup even if function panics\nFor more details, see Transactions Guide.","performance-characteristics#Performance Characteristics":"","registration-one-time-cost#Registration (One-Time Cost)":"When: At package initialization or first Register[] callWhat happens:\nReflection inspects struct fields\nQuery templates are built\nMetadata is cached in FieldMap\nCost: Milliseconds per type, happens once","query-execution-runtime#Query Execution (Runtime)":"What happens:\nLookup FieldMap from global cache (O(1) map lookup)\nUse pre-built query template\nBuild pointers to struct fields using cached indexes\nExecute query and scan\nCost: Comparable to hand-written database/sql codeNo runtime reflection: Field positions are pre-calculated during registration.","type-safety-with-generics#Type Safety with Generics":"go-lightning leverages Go 1.18+ generics for compile-time type safety:\n// ✅ Type-safe: Returns []*User\nusers, err := lpg.SelectGeneric[User](tx, query)\n// ✅ Compiler knows this is *User\nuser, err := lpg.SelectGenericSingle[User](tx, query, args...)\n// ✅ Type parameter ensures correct struct type\nid, err := lpg.InsertGeneric(tx, &user)  // user must be *User\nBenefits:\nIDE autocomplete for returned types\nCompile-time error if wrong type used\nNo type assertions needed\nRefactoring safety","validation-and-error-handling#Validation and Error Handling":"","column-validation#Column Validation":"go-lightning validates that all columns returned by SELECT queries exist in the registered struct:\n// Struct has: Id, FirstName, LastName, Email\nusers, err := lpg.SelectGeneric[User](tx, \"SELECT *, created_at FROM users\")\n// Panic: invalid column 'created_at' is not found in the struct\nSolution: Only select columns that exist in your struct:\nusers, err := lpg.SelectGeneric[User](tx,\n    \"SELECT id, first_name, last_name, email FROM users\")","no-rows-vs-errors#No Rows vs Errors":"go-lightning distinguishes between \"no rows found\" and actual errors:\nuser, err := lpg.SelectGenericSingle[User](tx, \"SELECT * FROM users WHERE id = $1\", 999)\n// If no rows: user == nil, err == nil\n// If error: user == nil, err != nil\nAlways check both:\nif err != nil {\n    return err  // Actual error\n}\nif user == nil {\n    return errors.New(\"user not found\")  // No rows\n}","summary#Summary":"Concept\tKey Points\tRegistration\tRequired before generic operations; happens once in init()\tFieldMap\tPre-built metadata for fast query execution\tNaming Strategy\tConverts Go names to database names (customizable)\tID Handling\tSpecial behavior for int (auto-increment) and string (UUID)\tGeneric vs Manual\tGeneric = automatic mapping; Manual = custom control\tTransactions\tAll operations require *sql.Tx for safety\tPerformance\tReflection at init time, zero runtime reflection\tType Safety\tGenerics provide compile-time checking","next-steps#Next Steps":"PostgreSQL Guide - PostgreSQL-specific features\nMySQL Guide - MySQL-specific features\nRegistration Guide - Deep dive into registration\nNaming Strategies - Custom naming conventions\nAPI Reference - Complete interface documentation"}},"/troubleshooting/migration-guide":{"title":"Migration Guide","data":{"":"Migrating to go-lightning from other approaches.","from-databasesql#From database/sql":"","before-databasesql#Before (database/sql)":"var id int\nvar name string\nvar email string\nrows, err := db.Query(\"SELECT id, name, email FROM users\")\nfor rows.Next() {\n    err := rows.Scan(&id, &name, &email)\n    // ...\n}","after-go-lightning#After (go-lightning)":"type User struct {\n    Id    int\n    Name  string\n    Email string\n}\nfunc init() {\n    lpg.Register[User]()\n}\nusers, err := lpg.SelectGeneric[User](tx, \"SELECT * FROM users\")","from-gorm#From GORM":"","before-gorm#Before (GORM)":"var users []User\ndb.Where(\"age > ?\", 25).Find(&users)\nuser := User{Name: \"John\"}\ndb.Create(&user)","after-go-lightning-1#After (go-lightning)":"users, err := lpg.SelectGeneric[User](tx,\n    \"SELECT * FROM users WHERE age > $1\", 25)\nid, err := lpg.InsertGeneric(tx, &User{Name: \"John\"})\nKey Differences:\ngo-lightning requires explicit SQL\ngo-lightning uses transactions\ngo-lightning has less \"magic\"","incremental-adoption#Incremental Adoption":"You can use go-lightning alongside existing code:\n// Existing database/sql code\nrows, _ := db.Query(\"SELECT * FROM products\")\n// New go-lightning code\ntx, _ := db.Begin()\nusers, _ := lpg.SelectGeneric[User](tx, \"SELECT * FROM users\")\ntx.Commit()\nSee Introduction for philosophy comparison."}},"/guides/registration":{"title":"Registration System","data":{"":"A deep dive into go-lightning's registration system and how it enables type-safe database operations.","why-registration-exists#Why Registration Exists":"go-lightning uses a one-time registration pattern to build metadata about your struct types. This metadata enables:\nFast query execution - Pre-built query templates avoid runtime string building\nType-safe mapping - Compile-time verification of struct types\nZero runtime reflection - Field positions calculated once, reused forever\nAutomatic naming - Go names → database names without manual configuration","how-to-register#How to Register":"","basic-registration#Basic Registration":"Call Register[T]() in an init() function:\npackage models\nimport \"github.com/tracewayapp/go-lightning/lpg\"\ntype User struct {\n    Id        int\n    FirstName string\n    LastName  string\n    Email     string\n}\nfunc init() {\n    lpg.Register[User]()  // PostgreSQL\n    // or\n    // lmy.Register[User]()  // MySQL\n}","why-init#Why init()?":"The init() function is the recommended place for registration:\nfunc init() {\n    lpg.Register[User]()\n}\nBenefits:\nRuns automatically when package is imported\nExecutes exactly once\nHappens before main() starts\nNo risk of forgetting to register\nThread-safe initialization\nAlternative (not recommended):\nfunc main() {\n    lpg.Register[User]()  // Works but easy to forget\n    // ... rest of code\n}","multiple-struct-registration#Multiple Struct Registration":"Register each struct type in its own package:\n// models/user.go\npackage models\nimport \"github.com/tracewayapp/go-lightning/lpg\"\ntype User struct { /* ... */ }\nfunc init() {\n    lpg.Register[User]()\n}\n// models/product.go\npackage models\ntype Product struct { /* ... */ }\nfunc init() {\n    lpg.Register[Product]()\n}\n// main.go\npackage main\nimport (\n    \"yourproject/models\"  // All init() functions run automatically\n)","what-happens-during-registration#What Happens During Registration":"When you call Register[User](), go-lightning performs these steps:","1-reflect-on-struct-type#1. Reflect on Struct Type":"Uses Go's reflect package to inspect the struct:\ntype User struct {\n    Id        int     // Field 0\n    FirstName string  // Field 1\n    LastName  string  // Field 2\n    Email     string  // Field 3\n}\nExtracted:\nField names: [\"Id\", \"FirstName\", \"LastName\", \"Email\"]\nField types: [int, string, string, string]\nField count: 4","2-apply-naming-strategy#2. Apply Naming Strategy":"Converts Go names to database names using DbNamingStrategy:Struct name → Table name:\n\"User\" → \"user\" → \"users\"  // snake_case + plural\nField names → Column names:\n\"Id\"        → \"id\"\n\"FirstName\" → \"first_name\"\n\"LastName\"  → \"last_name\"\n\"Email\"     → \"email\"","3-detect-id-field#3. Detect ID Field":"Checks if there's an Id field and its type:\n// Integer ID\ntype User struct {\n    Id int  // hasIntId = true\n}\n// String ID (UUID)\ntype Entity struct {\n    Id string  // hasIntId = false\n}\n// No ID field\ntype Log struct {\n    Timestamp time.Time  // hasIntId = false\n    Message   string\n}","4-build-query-templates#4. Build Query Templates":"Generates INSERT and UPDATE query templates:INSERT query (PostgreSQL with int ID):\nINSERT INTO users (first_name, last_name, email) VALUES ($1, $2, $3) RETURNING id\n--                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^        ^^^^^^^^^^^\n--                 Excludes 'id' field                   Parameters: $1, $2, $3\nUPDATE query:\nUPDATE users SET first_name = $1, last_name = $2, email = $3 WHERE\n--               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n--               All fields (WHERE clause added at call time)","5-store-fieldmap#5. Store FieldMap":"Saves all metadata in a global map for O(1) lookup:\ntype FieldMap struct {\n    ColumnsMap    map[string]int  // \"first_name\" → 1\n    ColumnKeys    []string         // [\"id\", \"first_name\", ...]\n    HasIntId      bool             // true\n    InsertQuery   string           // \"INSERT INTO users ...\"\n    UpdateQuery   string           // \"UPDATE users SET ...\"\n    InsertColumns []string         // [\"first_name\", \"last_name\", \"email\"]\n}","the-fieldmap-structure#The FieldMap Structure":"","columnsmap#ColumnsMap":"Maps column names to struct field indices:\nColumnsMap: {\n    \"id\":         0,\n    \"first_name\": 1,\n    \"last_name\":  2,\n    \"email\":      3,\n}\nUsed for:\nValidating SELECT query columns\nBuilding scan pointers in correct order","columnkeys#ColumnKeys":"Ordered list of all column names:\nColumnKeys: [\"id\", \"first_name\", \"last_name\", \"email\"]\nUsed for:\nBuilding UPDATE SET clauses\nIterating fields in order","hasintid#HasIntId":"Boolean flag indicating integer ID field:\nHasIntId: true  // struct has `Id int` field\nUsed for:\nINSERT query generation (exclude ID or not)\nRETURNING clause (PostgreSQL)\nLastInsertId handling (MySQL)","insertquery#InsertQuery":"Pre-built INSERT query template:\nInsertQuery: \"INSERT INTO users (first_name, last_name, email) VALUES ($1, $2, $3) RETURNING id\"\nUsed for:\nInsertGeneric operations\nAvoids runtime string building","updatequery#UpdateQuery":"Pre-built UPDATE query template (without WHERE):\nUpdateQuery: \"UPDATE users SET first_name = $1, last_name = $2, email = $3 WHERE \"\nUsed for:\nUpdateGeneric operations\nWHERE clause appended at call time","insertcolumns#InsertColumns":"Column names for INSERT (excludes auto-increment ID):\nInsertColumns: [\"first_name\", \"last_name\", \"email\"]\nUsed for:\nDetermining which struct fields to include in INSERT\nBuilding value list in correct order","custom-query-generators#Custom Query Generators":"For advanced use cases, implement InsertUpdateQueryGenerator:\ntype InsertUpdateQueryGenerator interface {\n    GenerateInsertQuery(tableName string, columnKeys []string, hasIntId bool) (string, []string)\n    GenerateUpdateQuery(tableName string, columnKeys []string) string\n}","example-custom-insert-query#Example: Custom INSERT Query":"type CustomQueryGenerator struct{}\nfunc (CustomQueryGenerator) GenerateInsertQuery(tableName string, columnKeys []string, hasIntId bool) (string, []string) {\n    // Example: Always include created_at timestamp\n    var sb strings.Builder\n    sb.WriteString(\"INSERT INTO \")\n    sb.WriteString(tableName)\n    sb.WriteString(\" (\")\n    insertColumns := []string{}\n    for i, col := range columnKeys {\n        if hasIntId && col == \"id\" {\n            continue  // Skip ID\n        }\n        if i > 0 {\n            sb.WriteString(\", \")\n        }\n        sb.WriteString(col)\n        insertColumns = append(insertColumns, col)\n    }\n    sb.WriteString(\", created_at) VALUES (\")\n    // Add placeholders\n    for i := range insertColumns {\n        if i > 0 {\n            sb.WriteString(\", \")\n        }\n        sb.WriteString(fmt.Sprintf(\"$%d\", i+1))\n    }\n    sb.WriteString(\", NOW()) RETURNING id\")\n    return sb.String(), insertColumns\n}\nfunc (CustomQueryGenerator) GenerateUpdateQuery(tableName string, columnKeys []string) string {\n    // Standard UPDATE\n    var sb strings.Builder\n    sb.WriteString(\"UPDATE \")\n    sb.WriteString(tableName)\n    sb.WriteString(\" SET \")\n    for i, col := range columnKeys {\n        if i > 0 {\n            sb.WriteString(\", \")\n        }\n        sb.WriteString(fmt.Sprintf(\"%s = $%d\", col, i+1))\n    }\n    sb.WriteString(\", updated_at = NOW() WHERE \")\n    return sb.String()\n}\n// Usage\nimport golightning \"github.com/tracewayapp/go-lightning\"\nfunc init() {\n    golightning.Register[User](\n        golightning.DefaultDbNamingStrategy{},\n        CustomQueryGenerator{},\n    )\n}","retrieving-fieldmap#Retrieving FieldMap":"Access the FieldMap for debugging or advanced use:\nimport (\n    \"reflect\"\n    golightning \"github.com/tracewayapp/go-lightning\"\n)\nuserType := reflect.TypeOf(User{})\nfieldMap, err := golightning.GetFieldMap(userType)\nif err != nil {\n    log.Fatal(\"User type not registered:\", err)\n}\nfmt.Println(\"Table:\", fieldMap.TableName)\nfmt.Println(\"Columns:\", fieldMap.ColumnKeys)\nfmt.Println(\"INSERT:\", fieldMap.InsertQuery)","registration-errors#Registration Errors":"","error-non-registered-model-x-used#Error: \"Non registered model X used\"":"Cause: Type was never registeredSolution:\n// ❌ Forgot to register\ntype User struct { /* ... */ }\nfunc main() {\n    id, err := lpg.InsertGeneric(tx, &User{})\n    // Panic: Non registered model User used\n}\n// ✅ Register in init()\nfunc init() {\n    lpg.Register[User]()\n}","error-type-already-registered#Error: \"type already registered\"":"Cause: Register[T]() called multiple timesWhy it happens:\nUsually safe if in init() (runs only once)\nProblem if called in regular function multiple times\nSolution:\n// ✅ Safe - init() runs once per package\nfunc init() {\n    lpg.Register[User]()\n}\n// ❌ Don't do this\nfunc Setup() {\n    lpg.Register[User]()  // Could be called multiple times\n}","performance-impact#Performance Impact":"","registration-one-time#Registration (One-Time)":"Cost:\nReflection: ~1-5 microseconds per struct\nQuery building: ~1-2 microseconds\nMap storage: negligible\nTotal: ~10 microseconds per type at startupFor 100 struct types: ~1 millisecond total","query-execution-runtime#Query Execution (Runtime)":"Without go-lightning (manual SQL):\nHand-write query: \"SELECT * FROM users WHERE id = $1\"\nExecute query\nManually scan: rows.Scan(&id, &name, &email)\nWith go-lightning:\nLookup FieldMap: O(1) map access (~10 nanoseconds)\nUse pre-built template\nAuto-scan using cached field positions\nPerformance: Identical to manual SQL (within measurement error)","best-practices#Best Practices":"","1-register-in-init#1. Register in init()":"// ✅ Recommended\nfunc init() {\n    lpg.Register[User]()\n}\n// ❌ Avoid\nfunc main() {\n    lpg.Register[User]()\n}","2-one-struct-per-file#2. One Struct Per File":"// user.go\ntype User struct { /* ... */ }\nfunc init() { lpg.Register[User]() }\n// product.go\ntype Product struct { /* ... */ }\nfunc init() { lpg.Register[Product]() }","3-co-locate-models-and-registration#3. Co-locate Models and Registration":"// models/user.go\npackage models\nimport \"github.com/tracewayapp/go-lightning/lpg\"\ntype User struct {\n    Id   int\n    Name string\n}\nfunc init() {\n    lpg.Register[User]()  // Right next to struct definition\n}","4-dont-register-third-party-structs#4. Don't Register Third-Party Structs":"// ❌ Don't register types you don't own\nimport \"github.com/someone/library\"\nfunc init() {\n    lpg.Register[library.TheirStruct]()  // Bad idea\n}\n// ✅ Create your own wrapper type\ntype MyStruct struct {\n    library.TheirStruct\n    MyField string\n}\nfunc init() {\n    lpg.Register[MyStruct]()\n}","summary#Summary":"Aspect\tDetails\tWhen\tinit() function\tWhat\tBuilds FieldMap metadata\tCost\t~10μs per type, one-time\tRuntime\tO(1) lookup, zero reflection\tRequired\tFor all generic operations\tOptional\tNot needed for manual operations","next-steps#Next Steps":"Naming Strategies - Customize name mapping\nCore Concepts - Architecture overview\nAPI Reference - Register function documentation"}},"/guides/postgresql":{"title":"PostgreSQL Guide","data":{"":"This guide covers PostgreSQL-specific features and best practices when using go-lightning with PostgreSQL.","installation#Installation":"go get github.com/tracewayapp/go-lightning/lpg\ngo get github.com/jackc/pgx/v5/stdlib","basic-setup#Basic Setup":"","import-and-driver-registration#Import and Driver Registration":"package main\nimport (\n    \"database/sql\"\n    _ \"github.com/jackc/pgx/v5/stdlib\"  // PostgreSQL driver\n    \"github.com/tracewayapp/go-lightning/lpg\"\n    \"yourproject/models\"\n)","connection-string#Connection String":"db, err := sql.Open(\"pgx\", \"postgres://user:password@localhost:5432/dbname?sslmode=disable\")\nif err != nil {\n    log.Fatal(err)\n}\ndefer db.Close()\nCommon parameters:\nsslmode=disable - Disable SSL (development only)\nsslmode=require - Require SSL (production)\npool_max_conns=10 - Maximum connections\npool_min_conns=2 - Minimum connections","parameter-placeholders#Parameter Placeholders":"PostgreSQL uses numbered placeholders: $1, $2, $3, etc.\n// Single parameter\nuser, err := lpg.SelectGenericSingle[User](tx,\n    \"SELECT * FROM users WHERE id = $1\", userId)\n// Multiple parameters\nusers, err := lpg.SelectGeneric[User](tx,\n    \"SELECT * FROM users WHERE age > $1 AND city = $2\", 25, \"New York\")\n// IN clause\nids := []int{1, 2, 3}\nquery := fmt.Sprintf(\"SELECT * FROM users WHERE id IN (%s)\",\n    lpg.JoinForIn(ids))\nusers, err := lpg.SelectGeneric[User](tx, query)","insert-with-returning#INSERT with RETURNING":"PostgreSQL's lpg.InsertGeneric uses the RETURNING id clause to retrieve auto-generated IDs:\nuser := &User{\n    FirstName: \"John\",\n    LastName:  \"Doe\",\n    Email:     \"john@example.com\",\n}\nid, err := lpg.InsertGeneric(tx, user)\nif err != nil {\n    log.Fatal(err)\n}\nfmt.Printf(\"Inserted user with ID: %d\\n\", id)\nGenerated SQL:\nINSERT INTO users (first_name, last_name, email)\nVALUES ($1, $2, $3)\nRETURNING id\nWhy this matters:\nPostgreSQL doesn't support LastInsertId() like MySQL\nRETURNING id retrieves the generated ID in a single roundtrip\nMore efficient than a separate SELECT query","uuid-support#UUID Support":"PostgreSQL excels at UUID primary keys. go-lightning provides built-in UUID support:","auto-generated-uuid#Auto-Generated UUID":"type Entity struct {\n    Id          string  // UUID will be auto-generated\n    Name        string\n    Description string\n}\nfunc init() {\n    lpg.Register[Entity]()\n}\n// Usage\nentity := &Entity{\n    Name:        \"My Entity\",\n    Description: \"Description here\",\n}\nuuid, err := lpg.InsertGenericUuid(tx, entity)\nif err != nil {\n    log.Fatal(err)\n}\n// entity.Id is now set to the generated UUID\nfmt.Printf(\"Generated UUID: %s\\n\", uuid)\nfmt.Printf(\"Entity ID: %s\\n\", entity.Id)","pre-generated-uuid#Pre-Generated UUID":"If you generate the UUID yourself:\nimport \"github.com/google/uuid\"\nentity := &Entity{\n    Id:          uuid.New().String(),\n    Name:        \"My Entity\",\n    Description: \"Description here\",\n}\nerr := lpg.InsertGenericExistingUuid(tx, entity)\nif err != nil {\n    log.Fatal(err)\n}","database-schema-for-uuid#Database Schema for UUID":"CREATE TABLE entities (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    name TEXT NOT NULL,\n    description TEXT\n);\nOr use extension for older PostgreSQL versions:\nCREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\nCREATE TABLE entities (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    name TEXT NOT NULL,\n    description TEXT\n);","parameter-offset-handling-in-where-clauses#Parameter Offset Handling in WHERE Clauses":"go-lightning automatically renumbers $N placeholders in WHERE clauses for UpdateGeneric:\nuser := &User{\n    Id:        1,\n    FirstName: \"Jane\",\n    LastName:  \"Doe\",\n    Email:     \"jane@example.com\",\n}\n// UpdateGeneric automatically adjusts parameter numbers\nerr := lpg.UpdateGeneric(tx, user, \"id = $1\", user.Id)\nWhat happens internally:\nUPDATE query uses $1, $2, $3 for struct fields\nWHERE clause parameter $1 is renumbered to $4\nFinal query: UPDATE users SET first_name = $1, last_name = $2, email = $3 WHERE id = $4\nThis allows intuitive WHERE clauses:\n// Simple WHERE\nlpg.UpdateGeneric(tx, user, \"id = $1\", user.Id)\n// Complex WHERE\nlpg.UpdateGeneric(tx, user, \"id = $1 AND organization_id = $2\", userId, orgId)\nWithout automatic renumbering, you'd need:\n// This would be error-prone\nlpg.UpdateGeneric(tx, user, \"id = $4 AND organization_id = $5\", userId, orgId)\n//                                     ^^               ^^  <- Hard to track!","dynamic-in-clauses#Dynamic IN Clauses":"","for-integer-ids#For Integer IDs":"Use JoinForIn to build comma-separated lists:\nids := []int{1, 2, 3, 4, 5}\nquery := fmt.Sprintf(\"SELECT * FROM users WHERE id IN (%s)\", lpg.JoinForIn(ids))\nusers, err := lpg.SelectGeneric[User](tx, query)\nOutput: SELECT * FROM users WHERE id IN (1,2,3,4,5)","for-parameterized-in-clauses#For Parameterized IN Clauses":"Use JoinStringForIn with parameter offset:\nusernames := []string{\"alice\", \"bob\", \"charlie\"}\nquery := fmt.Sprintf(\"SELECT * FROM users WHERE username IN (%s)\",\n    lpg.JoinStringForIn(0, usernames))\nusers, err := lpg.SelectGeneric[User](tx, query, usernames...)\nOutput:\nQuery: SELECT * FROM users WHERE username IN ($1,$2,$3)\nArgs: [\"alice\", \"bob\", \"charlie\"]\nWith offset (e.g., after other parameters):\nage := 25\nusernames := []string{\"alice\", \"bob\"}\nquery := fmt.Sprintf(\"SELECT * FROM users WHERE age > $1 AND username IN (%s)\",\n    lpg.JoinStringForIn(1, usernames))  // offset=1 because $1 is used for age\nusers, err := lpg.SelectGeneric[User](tx, query, age, usernames...)\nOutput:\nQuery: SELECT * FROM users WHERE age > $1 AND username IN ($2,$3)\nArgs: [25, \"alice\", \"bob\"]","transaction-patterns#Transaction Patterns":"","basic-transaction#Basic Transaction":"tx, err := db.Begin()\nif err != nil {\n    return err\n}\ndefer tx.Rollback()  // Safe even after Commit()\n// Operations\nid, err := lpg.InsertGeneric(tx, &user)\nif err != nil {\n    return err  // Rollback via defer\n}\n// Commit\nif err := tx.Commit(); err != nil {\n    return err\n}","transaction-with-isolation-level#Transaction with Isolation Level":"tx, err := db.BeginTx(context.Background(), &sql.TxOptions{\n    Isolation: sql.LevelSerializable,\n})\nAvailable levels:\nsql.LevelDefault - Database default\nsql.LevelReadUncommitted\nsql.LevelReadCommitted - PostgreSQL default\nsql.LevelRepeatableRead\nsql.LevelSerializable - Strongest isolation","best-practices#Best Practices":"","1-use-connection-pooling#1. Use Connection Pooling":"db.SetMaxOpenConns(25)\ndb.SetMaxIdleConns(5)\ndb.SetConnMaxLifetime(5 * time.Minute)","2-always-use-transactions#2. Always Use Transactions":"Even for single operations, transactions provide:\nConsistency guarantees\nExplicit commit/rollback control\nBetter error handling","3-prefer-uuid-for-distributed-systems#3. Prefer UUID for Distributed Systems":"type User struct {\n    Id    string  // UUID\n    Name  string\n    Email string\n}\nAdvantages:\nNo coordination needed across databases\nMerge-friendly (no ID conflicts)\nCan generate client-side","4-use-jsonb-for-flexible-data#4. Use JSONB for Flexible Data":"PostgreSQL's JSONB type works well with go-lightning:\ntype Product struct {\n    Id         int\n    Name       string\n    Attributes string  // JSON string\n}\n// In your application\nimport \"encoding/json\"\nattrs := map[string]interface{}{\n    \"color\": \"red\",\n    \"size\":  \"large\",\n}\nattrsJSON, _ := json.Marshal(attrs)\nproduct := &Product{\n    Name:       \"T-Shirt\",\n    Attributes: string(attrsJSON),\n}\nSchema:\nCREATE TABLE products (\n    id SERIAL PRIMARY KEY,\n    name TEXT NOT NULL,\n    attributes JSONB\n);","5-use-prepared-statements-for-repeated-queries#5. Use Prepared Statements for Repeated Queries":"While go-lightning doesn't expose prepared statements directly, the underlying database/sql driver handles this:\n// The driver automatically prepares this query\nfor _, email := range emails {\n    user, _ := lpg.SelectGenericSingle[User](tx,\n        \"SELECT * FROM users WHERE email = $1\", email)\n}","postgresql-specific-features#PostgreSQL-Specific Features":"","serial-vs-identity#SERIAL vs IDENTITY":"Modern PostgreSQL (10+) prefers IDENTITY:\n-- Old way (SERIAL)\nCREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    name TEXT\n);\n-- New way (IDENTITY) - Recommended\nCREATE TABLE users (\n    id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,\n    name TEXT\n);\nBoth work with go-lightning's auto-increment detection.","array-types#Array Types":"PostgreSQL arrays can be used with custom mapLine functions:\ntype User struct {\n    Id    int\n    Name  string\n    Tags  []string  // PostgreSQL array\n}\n// Use manual operations for arrays\nfunc mapUser(rows *sql.Rows, user *User) error {\n    return rows.Scan(&user.Id, &user.Name, pq.Array(&user.Tags))\n}\nusers, err := lpg.SelectMultiple[User](tx, mapUser,\n    \"SELECT id, name, tags FROM users\")","full-text-search#Full-Text Search":"query := `\n    SELECT * FROM articles\n    WHERE to_tsvector('english', title || ' ' || content) @@ plainto_tsquery($1)\n`\narticles, err := lpg.SelectGeneric[Article](tx, query, \"golang database\")","common-patterns#Common Patterns":"","upsert-insert--on-conflict#Upsert (INSERT ... ON CONFLICT)":"query := `\n    INSERT INTO users (id, name, email)\n    VALUES ($1, $2, $3)\n    ON CONFLICT (email)\n    DO UPDATE SET name = EXCLUDED.name\n    RETURNING id\n`\nid, err := lpg.Insert(tx, query, user.Id, user.Name, user.Email)","bulk-insert#Bulk Insert":"query := `\n    INSERT INTO users (first_name, last_name, email)\n    VALUES ($1, $2, $3), ($4, $5, $6), ($7, $8, $9)\n    RETURNING id\n`\nrows, err := tx.Query(query,\n    \"John\", \"Doe\", \"john@example.com\",\n    \"Jane\", \"Doe\", \"jane@example.com\",\n    \"Bob\", \"Smith\", \"bob@example.com\",\n)\n// Scan IDs...","soft-deletes#Soft Deletes":"type User struct {\n    Id        int\n    Name      string\n    DeletedAt *time.Time  // NULL when not deleted\n}\n// Soft delete\nerr := lpg.Update(tx, \"UPDATE users SET deleted_at = NOW() WHERE id = $1\", userId)\n// Query only active users\nusers, err := lpg.SelectGeneric[User](tx,\n    \"SELECT * FROM users WHERE deleted_at IS NULL\")","troubleshooting#Troubleshooting":"","pq-sorry-too-many-clients-already#\"pq: sorry, too many clients already\"":"Reduce connection pool size:\ndb.SetMaxOpenConns(10)","pq-ssl-is-not-enabled-on-the-server#\"pq: SSL is not enabled on the server\"":"Either enable SSL on server or disable in connection string:\n\"postgres://user:pass@host/db?sslmode=disable\"","pq-column-x-does-not-exist#\"pq: column 'X' does not exist\"":"Check naming strategy mapping:\nGo: CreatedAt → Database: created_at\nEnsure struct fields match database columns","next-steps#Next Steps":"Transactions Guide - Advanced transaction patterns\nUUID Entities Example - Complete UUID example\nPostgreSQL API Reference - Full API documentation"}},"/":{"title":"go-lightning","data":{"":"Lightning-fast database operations with Go generics","overview#Overview":"go-lightning is a lightweight Go library that simplifies database operations using generics. It provides type-safe wrappers around database/sql with automatic struct-to-table mapping, reducing boilerplate for common CRUD operations while maintaining full control and performance.","key-features#Key Features":"Type-Safe CRUD Operations - Leverage Go generics for compile-time type safety\nAutomatic Struct Mapping - Zero-boilerplate mapping between structs and database tables\nMultiple Database Support - PostgreSQL and MySQL implementations included\nUUID Generation - Built-in UUID support for string-based primary keys\nFlexible Naming Strategies - Customize how struct names map to table/column names\nTransaction-Based - Explicit transaction management for predictable behavior","quick-example#Quick Example":"","before-raw-sql#Before (Raw SQL)":"type User struct {\n    Id        int\n    FirstName string\n    LastName  string\n    Email     string\n}\nfunc InsertUser(tx *sql.Tx, user *User) (int, error) {\n    var id int\n    query := `INSERT INTO users (first_name, last_name, email)\n              VALUES ($1, $2, $3) RETURNING id`\n    err := tx.QueryRow(query, user.FirstName, user.LastName, user.Email).Scan(&id)\n    return id, err\n}\nfunc GetUser(tx *sql.Tx, id int) (*User, error) {\n    user := &User{}\n    query := `SELECT id, first_name, last_name, email FROM users WHERE id = $1`\n    err := tx.QueryRow(query, id).Scan(&user.Id, &user.FirstName, &user.LastName, &user.Email)\n    if err == sql.ErrNoRows {\n        return nil, nil\n    }\n    return user, err\n}","after-go-lightning#After (go-lightning)":"import \"github.com/tracewayapp/go-lightning/lpg\"\ntype User struct {\n    Id        int\n    FirstName string\n    LastName  string\n    Email     string\n}\nfunc init() {\n    lpg.Register[User]()  // One-time registration\n}\n// Insert\nid, err := lpg.InsertGeneric(tx, &user)\n// Select\nuser, err := lpg.SelectGenericSingle[User](tx, \"SELECT * FROM users WHERE id = $1\", id)","installation#Installation":"","postgresql#PostgreSQL":"go get github.com/tracewayapp/go-lightning/lpg","mysql#MySQL":"go get github.com/tracewayapp/go-lightning/lmy","get-started#Get Started":"Quick Start Guide →\nView API Reference","why-go-lightning#Why go-lightning?":"","reduce-boilerplate#Reduce Boilerplate":"Write less code for common operations. No more manual Scan() calls or repetitive query builders for basic CRUD.","type-safety#Type Safety":"Compile-time type checking with Go generics. Catch errors before runtime.","stay-in-control#Stay in Control":"go-lightning is a thin layer over database/sql. You still write SQL queries and manage transactions explicitly. No magic, no surprises.","performance#Performance":"Reflection happens once at registration time. Query execution uses pre-built templates for zero runtime reflection overhead.","supported-databases#Supported Databases":"Database\tModule\tParameter Placeholders\tAuto-Increment\tPostgreSQL\tlpg\t$1, $2, $3...\tRETURNING id\tMySQL\tlmy\t?\tLastInsertId()","next-steps#Next Steps":"Quick Start Guide - Get up and running in 5 minutes\nCore Concepts - Understand the architecture\nPostgreSQL Guide - PostgreSQL-specific features\nMySQL Guide - MySQL-specific features\nExamples - Complete working examples"}}}
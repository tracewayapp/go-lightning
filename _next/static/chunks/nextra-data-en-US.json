{"/api-reference/functions":{"title":"API Reference","data":{"":"Complete reference for all go-lightning functions and types.","registration#Registration":"","registermodel#RegisterModel":"Registers a model with the default naming strategy.\nfunc RegisterModel[T any](driver Driver)\nParameters:\ndriver: Database driver (lit.PostgreSQL or lit.MySQL)\nExample:\nlit.RegisterModel[User](lit.PostgreSQL)","registermodelwithnaming#RegisterModelWithNaming":"Registers a model with a custom naming strategy.\nfunc RegisterModelWithNaming[T any](driver Driver, namingStrategy DbNamingStrategy)\nParameters:\ndriver: Database driver\nnamingStrategy: Implementation of DbNamingStrategy\nExample:\nlit.RegisterModelWithNaming[User](lit.PostgreSQL, MyNamingStrategy{})","query-functions#Query Functions":"","select#Select":"Executes a query and returns all matching rows.\nfunc Select[T any](ex Executor, query string, args ...any) ([]*T, error)\nParameters:\nex: Database connection or transaction\nquery: SQL SELECT query\nargs: Query parameters\nReturns:\n[]*T: Slice of pointers to results\nerror: Any error that occurred\nExample:\nusers, err := lit.Select[User](db, \"SELECT id, name, email FROM users WHERE active = $1\", true)","selectsingle#SelectSingle":"Executes a query and returns a single row or nil.\nfunc SelectSingle[T any](ex Executor, query string, args ...any) (*T, error)\nParameters:\nex: Database connection or transaction\nquery: SQL SELECT query\nargs: Query parameters\nReturns:\n*T: Pointer to result, or nil if not found\nerror: Any error that occurred\nExample:\nuser, err := lit.SelectSingle[User](db, \"SELECT id, name, email FROM users WHERE id = $1\", 123)","selectmultiplenative#SelectMultipleNative":"Executes a query with manual row scanning.\nfunc SelectMultipleNative[T any](\n    ex Executor,\n    mapLine func(*interface{ Scan(...any) error }, *T) error,\n    query string,\n    args ...any,\n) ([]*T, error)\nParameters:\nex: Database connection or transaction\nmapLine: Function to scan each row\nquery: SQL SELECT query\nargs: Query parameters\nExample:\nresults, err := lit.SelectMultipleNative[Result](db,\n    func(scanner *interface{ Scan(...any) error }, r *Result) error {\n        return (*scanner).Scan(&r.Name, &r.Value)\n    },\n    \"SELECT name, value FROM items\")","mutation-functions#Mutation Functions":"","insert#Insert":"Inserts a record and returns the generated ID.\nfunc Insert[T any](ex Executor, t *T) (int, error)\nParameters:\nex: Database connection or transaction\nt: Pointer to the struct to insert\nReturns:\nint: Generated ID\nerror: Any error that occurred\nExample:\nid, err := lit.Insert(db, &user)","insertuuid#InsertUuid":"Inserts a record with an auto-generated UUID.\nfunc InsertUuid[T any](ex Executor, t *T) (string, error)\nParameters:\nex: Database connection or transaction\nt: Pointer to the struct to insert (Id field will be set)\nReturns:\nstring: Generated UUID\nerror: Any error that occurred\nExample:\nuuid, err := lit.InsertUuid(db, &session)","insertexistinguuid#InsertExistingUuid":"Inserts a record with a pre-existing UUID.\nfunc InsertExistingUuid[T any](ex Executor, t *T) error\nParameters:\nex: Database connection or transaction\nt: Pointer to the struct to insert (Id must be set)\nReturns:\nerror: Any error that occurred\nExample:\nerr := lit.InsertExistingUuid(db, &session)","insertnative#InsertNative":"Executes a manual INSERT query.\nfunc InsertNative(ex Executor, query string, args ...any) (int, error)\nParameters:\nex: Database connection or transaction\nquery: SQL INSERT query\nargs: Query parameters\nReturns:\nint: Last inserted ID\nerror: Any error that occurred","update#Update":"Updates a record with a WHERE clause.\nfunc Update[T any](ex Executor, t *T, where string, args ...any) error\nParameters:\nex: Database connection or transaction\nt: Pointer to the struct with updated values\nwhere: WHERE clause (required, cannot be empty)\nargs: WHERE clause parameters\nReturns:\nerror: Any error that occurred\nExample:\nerr := lit.Update(db, &user, \"id = $1\", user.Id)","updatenative#UpdateNative":"Executes a manual UPDATE query.\nfunc UpdateNative(ex Executor, query string, args ...any) error\nParameters:\nex: Database connection or transaction\nquery: SQL UPDATE query\nargs: Query parameters","delete#Delete":"Executes a DELETE query.\nfunc Delete(ex Executor, query string, args ...any) error\nParameters:\nex: Database connection or transaction\nquery: SQL DELETE query\nargs: Query parameters\nExample:\nerr := lit.Delete(db, \"DELETE FROM users WHERE id = $1\", 123)","helper-functions#Helper Functions":"","joinforin#JoinForIn":"Creates a comma-separated string of integers for IN clauses.\nfunc JoinForIn(ids []int) string\nExample:\nids := []int{1, 2, 3}\nquery := \"SELECT * FROM users WHERE id IN (\" + lit.JoinForIn(ids) + \")\"\n// Result: SELECT * FROM users WHERE id IN (1,2,3)","joinstringforin#JoinStringForIn":"Creates parameterized placeholders for IN clauses.\nfunc JoinStringForIn[T any](offset int, params []string) string\nParameters:\noffset: Starting parameter number (for PostgreSQL)\nparams: Slice of values (used to determine count)\nExample:\nemails := []string{\"a@test.com\", \"b@test.com\"}\nplaceholders := lit.JoinStringForIn[User](0, emails)\n// PostgreSQL: $1,$2\n// MySQL: ?,?","joinstringforinwithdriver#JoinStringForInWithDriver":"Creates parameterized placeholders for a specific driver.\nfunc JoinStringForInWithDriver(driver Driver, offset int, count int) string\nExample:\nplaceholders := lit.JoinStringForInWithDriver(lit.PostgreSQL, 2, 3)\n// Result: $3,$4,$5","types#Types":"","driver#Driver":"Database driver enum.\ntype Driver int\nconst (\n    PostgreSQL Driver = iota\n    MySQL\n)","executor#Executor":"Interface for database operations (implemented by *sql.DB and *sql.Tx).\ntype Executor interface {\n    Exec(query string, args ...any) (sql.Result, error)\n    Query(query string, args ...any) (*sql.Rows, error)\n    QueryRow(query string, args ...any) *sql.Row\n}","dbnamingstrategy#DbNamingStrategy":"Interface for custom naming conventions.\ntype DbNamingStrategy interface {\n    GetTableNameFromStructName(string) string\n    GetColumnNameFromStructName(string) string\n}","defaultdbnamingstrategy#DefaultDbNamingStrategy":"Built-in naming strategy (CamelCase → snake_case).\ntype DefaultDbNamingStrategy struct{}","fieldmap#FieldMap":"Cached metadata for a registered model.\ntype FieldMap struct {\n    ColumnsMap    map[string]int  // Column name → field index\n    ColumnKeys    []string        // Ordered column names\n    HasIntId      bool            // Whether id is an integer\n    InsertQuery   string          // Pre-built INSERT query\n    UpdateQuery   string          // Pre-built UPDATE query (without WHERE)\n    InsertColumns []string        // Columns used in INSERT\n    Driver        Driver          // Database driver\n}"}},"/core-concepts/queries":{"title":"Queries","data":{"":"go-lightning provides two functions for reading data: Select for multiple rows and SelectSingle for a single row.","select#Select":"Returns all matching rows as a slice of pointers:\nfunc Select[T any](ex Executor, query string, args ...any) ([]*T, error)","example#Example":"// Get all users\nusers, err := lit.Select[User](db, \"SELECT id, first_name, last_name, email FROM users\")\nif err != nil {\n    return err\n}\nfor _, user := range users {\n    fmt.Printf(\"%s %s\\n\", user.FirstName, user.LastName)\n}","with-parameters#With Parameters":"// PostgreSQL\nusers, err := lit.Select[User](db,\n    \"SELECT id, first_name, last_name, email FROM users WHERE last_name = $1\",\n    \"Doe\")\n// MySQL\nusers, err := lit.Select[User](db,\n    \"SELECT id, first_name, last_name, email FROM users WHERE last_name = ?\",\n    \"Doe\")","selectsingle#SelectSingle":"Returns a single row or nil if not found:\nfunc SelectSingle[T any](ex Executor, query string, args ...any) (*T, error)","example-1#Example":"user, err := lit.SelectSingle[User](db,\n    \"SELECT id, first_name, last_name, email FROM users WHERE id = $1\", id)\nif err != nil {\n    return err\n}\nif user == nil {\n    fmt.Println(\"User not found\")\n    return nil\n}\nfmt.Printf(\"Found: %s\\n\", user.Email)","column-validation#Column Validation":"go-lightning validates that all columns in your SELECT match fields in your struct. This catches errors early:\n// This will return an error if 'nonexistent' is not a field in User\nusers, err := lit.Select[User](db,\n    \"SELECT id, first_name, nonexistent FROM users\")\n// Error: invalid column that is not found in the struct: nonexistent","projections-dtos#Projections (DTOs)":"You can project query results into any struct, not just your registered models. This is useful for:\nSelecting only specific columns\nJOINs that combine multiple tables\nAggregations","partial-select#Partial Select":"type UserSummary struct {\n    Id    int\n    Email string\n}\nlit.RegisterModel[UserSummary](lit.PostgreSQL)\nsummaries, err := lit.Select[UserSummary](db,\n    \"SELECT id, email FROM users\")","join-results#JOIN Results":"type UserWithOrder struct {\n    UserId    int\n    UserEmail string\n    OrderId   int\n    Total     float64\n}\nlit.RegisterModel[UserWithOrder](lit.PostgreSQL)\nresults, err := lit.Select[UserWithOrder](db, `\n    SELECT\n        u.id as user_id,\n        u.email as user_email,\n        o.id as order_id,\n        o.total\n    FROM users u\n    JOIN orders o ON o.user_id = u.id\n    WHERE o.total > $1`, 100.00)\nSee Projections & DTOs for more examples.","native-queries#Native Queries":"For complex scenarios where automatic mapping doesn't work, use SelectMultipleNative:\nfunc SelectMultipleNative[T any](\n    ex Executor,\n    mapLine func(*interface{ Scan(...any) error }, *T) error,\n    query string,\n    args ...any,\n) ([]*T, error)\nThis gives you full control over the scanning process:\ntype CustomResult struct {\n    Name  string\n    Count int\n}\nresults, err := lit.SelectMultipleNative[CustomResult](db,\n    func(scanner *interface{ Scan(...any) error }, r *CustomResult) error {\n        return (*scanner).Scan(&r.Name, &r.Count)\n    },\n    \"SELECT name, COUNT(*) FROM items GROUP BY name\")"}},"/core-concepts/transactions":{"title":"Transactions","data":{"":"go-lightning works seamlessly with database transactions through the Executor interface.","the-executor-interface#The Executor Interface":"All go-lightning functions accept an Executor:\ntype Executor interface {\n    Exec(query string, args ...any) (sql.Result, error)\n    Query(query string, args ...any) (*sql.Rows, error)\n    QueryRow(query string, args ...any) *sql.Row\n}\nBoth *sql.DB and *sql.Tx implement this interface, so you can use the same code with or without transactions.","basic-transaction-pattern#Basic Transaction Pattern":"func CreateUserWithProfile(db *sql.DB, user *User, profile *Profile) error {\n    tx, err := db.Begin()\n    if err != nil {\n        return err\n    }\n    defer tx.Rollback() // No-op if committed\n    // Insert user\n    userId, err := lit.Insert(tx, user)\n    if err != nil {\n        return err\n    }\n    // Insert profile with user ID\n    profile.UserId = userId\n    _, err = lit.Insert(tx, profile)\n    if err != nil {\n        return err\n    }\n    return tx.Commit()\n}","repository-pattern#Repository Pattern":"A common pattern is to accept an Executor in your repository methods:\ntype UserRepository struct{}\nfunc (r *UserRepository) Create(ex lit.Executor, user *User) (int, error) {\n    return lit.Insert(ex, user)\n}\nfunc (r *UserRepository) FindById(ex lit.Executor, id int) (*User, error) {\n    return lit.SelectSingle[User](ex,\n        \"SELECT id, first_name, last_name, email FROM users WHERE id = $1\", id)\n}\nfunc (r *UserRepository) Update(ex lit.Executor, user *User) error {\n    return lit.Update(ex, user, \"id = $1\", user.Id)\n}\nfunc (r *UserRepository) Delete(ex lit.Executor, id int) error {\n    return lit.Delete(ex, \"DELETE FROM users WHERE id = $1\", id)\n}","usage-without-transaction#Usage Without Transaction":"repo := &UserRepository{}\nuser, err := repo.FindById(db, 123)","usage-with-transaction#Usage With Transaction":"repo := &UserRepository{}\ntx, err := db.Begin()\nif err != nil {\n    return err\n}\ndefer tx.Rollback()\nuser, err := repo.FindById(tx, 123)\nif err != nil {\n    return err\n}\nuser.Email = \"new@example.com\"\nif err := repo.Update(tx, user); err != nil {\n    return err\n}\nreturn tx.Commit()","complete-example#Complete Example":"type OrderService struct {\n    db        *sql.DB\n    users     *UserRepository\n    orders    *OrderRepository\n    inventory *InventoryRepository\n}\nfunc (s *OrderService) PlaceOrder(userId int, items []OrderItem) error {\n    tx, err := s.db.Begin()\n    if err != nil {\n        return err\n    }\n    defer tx.Rollback()\n    // Verify user exists\n    user, err := s.users.FindById(tx, userId)\n    if err != nil {\n        return err\n    }\n    if user == nil {\n        return errors.New(\"user not found\")\n    }\n    // Create order\n    order := &Order{UserId: userId, Status: \"pending\"}\n    orderId, err := s.orders.Create(tx, order)\n    if err != nil {\n        return err\n    }\n    // Add items and update inventory\n    for _, item := range items {\n        item.OrderId = orderId\n        if _, err := s.orders.AddItem(tx, &item); err != nil {\n            return err\n        }\n        if err := s.inventory.Decrement(tx, item.ProductId, item.Quantity); err != nil {\n            return err\n        }\n    }\n    return tx.Commit()\n}","error-handling#Error Handling":"The deferred Rollback() pattern is safe because:\nIf Commit() succeeds, Rollback() is a no-op\nIf any error occurs before Commit(), the transaction is rolled back\nIf Commit() fails, the transaction is also rolled back\ntx, err := db.Begin()\nif err != nil {\n    return err\n}\ndefer tx.Rollback() // Safe: no-op after successful commit\n// ... operations ...\nif err := tx.Commit(); err != nil {\n    // Rollback already called by defer\n    return fmt.Errorf(\"failed to commit: %w\", err)\n}\nreturn nil"}},"/examples/crud-repository":{"title":"CRUD Repository Example","data":{"":"A complete example implementing the repository pattern with go-lightning.","project-structure#Project Structure":"myapp/\n├── main.go\n├── models/\n│   └── user.go\n├── repositories/\n│   └── user_repository.go\n└── go.mod","model-definition#Model Definition":"// models/user.go\npackage models\nimport \"time\"\ntype User struct {\n    Id        int\n    FirstName string\n    LastName  string\n    Email     string\n    Active    bool\n    CreatedAt time.Time\n    UpdatedAt time.Time\n}","repository-implementation#Repository Implementation":"// repositories/user_repository.go\npackage repositories\nimport (\n    \"myapp/models\"\n    \"time\"\n    \"github.com/tracewayapp/go-lightning/lit\"\n)\ntype UserRepository struct{}\n// Create inserts a new user and returns the generated ID\nfunc (r *UserRepository) Create(ex lit.Executor, user *models.User) (int, error) {\n    user.CreatedAt = time.Now()\n    user.UpdatedAt = time.Now()\n    user.Active = true\n    return lit.Insert(ex, user)\n}\n// FindById retrieves a user by ID, returns nil if not found\nfunc (r *UserRepository) FindById(ex lit.Executor, id int) (*models.User, error) {\n    return lit.SelectSingle[models.User](ex,\n        `SELECT id, first_name, last_name, email, active, created_at, updated_at\n         FROM users WHERE id = $1`, id)\n}\n// FindByEmail retrieves a user by email, returns nil if not found\nfunc (r *UserRepository) FindByEmail(ex lit.Executor, email string) (*models.User, error) {\n    return lit.SelectSingle[models.User](ex,\n        `SELECT id, first_name, last_name, email, active, created_at, updated_at\n         FROM users WHERE email = $1`, email)\n}\n// FindAll retrieves all users\nfunc (r *UserRepository) FindAll(ex lit.Executor) ([]*models.User, error) {\n    return lit.Select[models.User](ex,\n        `SELECT id, first_name, last_name, email, active, created_at, updated_at\n         FROM users ORDER BY id`)\n}\n// FindActive retrieves all active users\nfunc (r *UserRepository) FindActive(ex lit.Executor) ([]*models.User, error) {\n    return lit.Select[models.User](ex,\n        `SELECT id, first_name, last_name, email, active, created_at, updated_at\n         FROM users WHERE active = true ORDER BY id`)\n}\n// FindByIds retrieves users by a list of IDs\nfunc (r *UserRepository) FindByIds(ex lit.Executor, ids []int) ([]*models.User, error) {\n    if len(ids) == 0 {\n        return []*models.User{}, nil\n    }\n    return lit.Select[models.User](ex,\n        `SELECT id, first_name, last_name, email, active, created_at, updated_at\n         FROM users WHERE id IN (`+lit.JoinForIn(ids)+`) ORDER BY id`)\n}\n// Update updates an existing user\nfunc (r *UserRepository) Update(ex lit.Executor, user *models.User) error {\n    user.UpdatedAt = time.Now()\n    return lit.Update(ex, user, \"id = $1\", user.Id)\n}\n// Delete removes a user by ID\nfunc (r *UserRepository) Delete(ex lit.Executor, id int) error {\n    return lit.Delete(ex, \"DELETE FROM users WHERE id = $1\", id)\n}\n// SoftDelete marks a user as inactive\nfunc (r *UserRepository) SoftDelete(ex lit.Executor, id int) error {\n    return lit.UpdateNative(ex,\n        \"UPDATE users SET active = false, updated_at = $1 WHERE id = $2\",\n        time.Now(), id)\n}\n// Count returns the total number of users\nfunc (r *UserRepository) Count(ex lit.Executor) (int, error) {\n    type CountResult struct {\n        Count int\n    }\n    result, err := lit.SelectSingle[CountResult](ex, \"SELECT COUNT(*) as count FROM users\")\n    if err != nil {\n        return 0, err\n    }\n    return result.Count, nil\n}\n// Exists checks if a user with the given email exists\nfunc (r *UserRepository) Exists(ex lit.Executor, email string) (bool, error) {\n    type ExistsResult struct {\n        Exists bool\n    }\n    result, err := lit.SelectSingle[ExistsResult](ex,\n        \"SELECT EXISTS(SELECT 1 FROM users WHERE email = $1) as exists\", email)\n    if err != nil {\n        return false, err\n    }\n    return result.Exists, nil\n}","main-application#Main Application":"// main.go\npackage main\nimport (\n    \"database/sql\"\n    \"fmt\"\n    \"log\"\n    \"myapp/models\"\n    \"myapp/repositories\"\n    \"github.com/tracewayapp/go-lightning/lit\"\n    _ \"github.com/lib/pq\"\n)\nfunc init() {\n    // Register models at startup\n    lit.RegisterModel[models.User](lit.PostgreSQL)\n    // Register helper structs for queries\n    type CountResult struct{ Count int }\n    type ExistsResult struct{ Exists bool }\n    lit.RegisterModel[CountResult](lit.PostgreSQL)\n    lit.RegisterModel[ExistsResult](lit.PostgreSQL)\n}\nfunc main() {\n    // Connect to database\n    db, err := sql.Open(\"postgres\", \"postgres://localhost/mydb?sslmode=disable\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer db.Close()\n    // Create repository\n    userRepo := &repositories.UserRepository{}\n    // Create a user\n    user := &models.User{\n        FirstName: \"John\",\n        LastName:  \"Doe\",\n        Email:     \"john@example.com\",\n    }\n    id, err := userRepo.Create(db, user)\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Printf(\"Created user with ID: %d\\n\", id)\n    // Find by ID\n    found, err := userRepo.FindById(db, id)\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Printf(\"Found: %s %s\\n\", found.FirstName, found.LastName)\n    // Update\n    found.FirstName = \"Jane\"\n    if err := userRepo.Update(db, found); err != nil {\n        log.Fatal(err)\n    }\n    fmt.Println(\"Updated user\")\n    // List all\n    users, err := userRepo.FindAll(db)\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Printf(\"Total users: %d\\n\", len(users))\n    // Delete\n    if err := userRepo.Delete(db, id); err != nil {\n        log.Fatal(err)\n    }\n    fmt.Println(\"Deleted user\")\n}","database-schema#Database Schema":"CREATE TABLE IF NOT EXISTS users (\n    id SERIAL PRIMARY KEY,\n    first_name TEXT NOT NULL,\n    last_name TEXT NOT NULL,\n    email TEXT UNIQUE NOT NULL,\n    active BOOLEAN DEFAULT true,\n    created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n    updated_at TIMESTAMP NOT NULL DEFAULT NOW()\n);\nCREATE INDEX idx_users_email ON users(email);\nCREATE INDEX idx_users_active ON users(active);","using-with-transactions#Using with Transactions":"func CreateUserWithProfile(db *sql.DB, userRepo *repositories.UserRepository, profileRepo *repositories.ProfileRepository) error {\n    tx, err := db.Begin()\n    if err != nil {\n        return err\n    }\n    defer tx.Rollback()\n    // Create user\n    user := &models.User{\n        FirstName: \"John\",\n        LastName:  \"Doe\",\n        Email:     \"john@example.com\",\n    }\n    userId, err := userRepo.Create(tx, user)\n    if err != nil {\n        return err\n    }\n    // Create profile\n    profile := &models.Profile{\n        UserId: userId,\n        Bio:    \"Hello, world!\",\n    }\n    _, err = profileRepo.Create(tx, profile)\n    if err != nil {\n        return err\n    }\n    return tx.Commit()\n}","mysql-version#MySQL Version":"For MySQL, change the placeholder syntax:\nfunc (r *UserRepository) FindById(ex lit.Executor, id int) (*models.User, error) {\n    return lit.SelectSingle[models.User](ex,\n        `SELECT id, first_name, last_name, email, active, created_at, updated_at\n         FROM users WHERE id = ?`, id)\n}\nfunc (r *UserRepository) Update(ex lit.Executor, user *models.User) error {\n    user.UpdatedAt = time.Now()\n    return lit.Update(ex, user, \"id = ?\", user.Id)\n}\nfunc (r *UserRepository) Delete(ex lit.Executor, id int) error {\n    return lit.Delete(ex, \"DELETE FROM users WHERE id = ?\", id)\n}\nAnd register with MySQL driver:\nlit.RegisterModel[models.User](lit.MySQL)"}},"/getting-started/installation":{"title":"Installation","data":{"requirements#Requirements":"Go 1.21 or higher\nA supported database (PostgreSQL or MySQL)","install-go-lightning#Install go-lightning":"go get github.com/tracewayapp/go-lightning/lit","database-drivers#Database Drivers":"go-lightning works with standard database/sql drivers. Install the driver for your database:","postgresql#PostgreSQL":"# pgx (recommended)\ngo get github.com/jackc/pgx/v5/stdlib\n# or pq\ngo get github.com/lib/pq","mysql#MySQL":"go get github.com/go-sql-driver/mysql","verify-installation#Verify Installation":"Create a simple program to verify everything is working:\npackage main\nimport (\n    \"fmt\"\n    \"github.com/tracewayapp/go-lightning/lit\"\n)\ntype User struct {\n    Id    int\n    Name  string\n    Email string\n}\nfunc main() {\n    lit.RegisterModel[User](lit.PostgreSQL)\n    fmt.Println(\"go-lightning installed successfully!\")\n}\nRun it:\ngo run main.go\nIf you see \"go-lightning installed successfully!\", you're ready to proceed to the Quick Start."}},"/getting-started/quick-start":{"title":"Quick Start","data":{"":"This guide will get you running with go-lightning in 5 minutes.","1-define-your-model#1. Define Your Model":"Create a struct that maps to your database table:\ntype User struct {\n    Id        int\n    FirstName string\n    LastName  string\n    Email     string\n}\nField names are automatically converted to snake_case column names:\nId → id\nFirstName → first_name\nLastName → last_name","2-create-your-table#2. Create Your Table":"Create the corresponding table in your database:\n-- PostgreSQL\nCREATE TABLE IF NOT EXISTS users (\n    id SERIAL PRIMARY KEY,\n    first_name TEXT NOT NULL,\n    last_name TEXT NOT NULL,\n    email TEXT UNIQUE NOT NULL\n);\n-- MySQL\nCREATE TABLE IF NOT EXISTS users (\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    first_name VARCHAR(255) NOT NULL,\n    last_name VARCHAR(255) NOT NULL,\n    email VARCHAR(255) UNIQUE NOT NULL\n);","3-register-the-model#3. Register the Model":"At application startup, register your model with the appropriate driver:\nimport \"github.com/tracewayapp/go-lightning/lit\"\nfunc init() {\n    lit.RegisterModel[User](lit.PostgreSQL)\n    // or for MySQL:\n    // lit.RegisterModel[User](lit.MySQL)\n}\nRegistration only happens once and caches INSERT/UPDATE queries for optimal performance.We recommend registering the models in a centralized place that you invoke in your main function:\nimport \"github.com/tracewayapp/go-lightning/lit\"\nfunc RegisterModels() {\n    lit.RegisterModel[User](lit.PostgreSQL)\n    lit.RegisterModel[Invoice](lit.PostgreSQL)\n    // ... register other models\n}\nfunc main() {\n    // init config etc...\n    RegisterModels()\n    // start your server/the rest of your application code...\n}","4-connect-to-database#4. Connect to Database":"import (\n    \"database/sql\"\n    _ \"github.com/lib/pq\"  // PostgreSQL driver\n)\ndb, err := sql.Open(\"postgres\", \"postgres://user:pass@localhost/mydb?sslmode=disable\")\nif err != nil {\n    log.Fatal(err)\n}\ndefer db.Close()","5-perform-crud-operations#5. Perform CRUD Operations":"","create#Create":"user := User{\n    FirstName: \"John\",\n    LastName:  \"Doe\",\n    Email:     \"john@example.com\",\n}\nid, err := lit.Insert(db, &user)","read#Read":"// Select all\nusers, err := lit.Select[User](db,\n    \"SELECT id, first_name, last_name, email FROM users\")\n// Select single\nuser, err := lit.SelectSingle[User](db,\n    \"SELECT id, first_name, last_name, email FROM users WHERE id = $1\", id)","update#Update":"user.FirstName = \"Jane\"\nerr := lit.Update(db, &user, \"id = $1\", user.Id)","delete#Delete":"err := lit.Delete(db, \"DELETE FROM users WHERE id = $1\", id)","mysql-differences#MySQL Differences":"When using MySQL, use ? placeholders instead of $1, $2, etc:\n// MySQL uses ? placeholders\nuser, err := lit.SelectSingle[User](db,\n    \"SELECT id, first_name, last_name, email FROM users WHERE id = ?\", id)\nerr := lit.Update(db, &user, \"id = ?\", user.Id)\nerr := lit.Delete(db, \"DELETE FROM users WHERE id = ?\", id)","next-steps#Next Steps":"Learn about Registration and how it optimizes performance\nUnderstand Queries for reading data\nExplore Mutations for writes\nSee a complete CRUD Repository example"}},"/guides/naming-strategies":{"title":"Naming Strategies","data":{"":"go-lightning converts Go struct and field names to database table and column names using a naming strategy. The default converts CamelCase to snake_case, but you can customize this.","default-naming-strategy#Default Naming Strategy":"The built-in DefaultDbNamingStrategy applies these rules:","table-names#Table Names":"Struct name → snake_case + \"s\"\nStruct\tTable\tUser\tusers\tOrderItem\torder_items\tHTTPRequest\th_t_t_p_requests","column-names#Column Names":"Field name → snake_case\nField\tColumn\tId\tid\tFirstName\tfirst_name\tCreatedAt\tcreated_at\tUserID\tuser_i_d","the-dbnamingstrategy-interface#The DbNamingStrategy Interface":"type DbNamingStrategy interface {\n    GetTableNameFromStructName(string) string\n    GetColumnNameFromStructName(string) string\n}","custom-naming-strategy#Custom Naming Strategy":"Implement the interface to create your own naming rules:","example-prefix-tables#Example: Prefix Tables":"type PrefixedNamingStrategy struct {\n    Prefix string\n}\nfunc (s PrefixedNamingStrategy) GetTableNameFromStructName(name string) string {\n    return s.Prefix + toSnakeCase(name) + \"s\"\n}\nfunc (s PrefixedNamingStrategy) GetColumnNameFromStructName(name string) string {\n    return toSnakeCase(name)\n}\nfunc toSnakeCase(s string) string {\n    var result strings.Builder\n    for i, r := range s {\n        if unicode.IsUpper(r) {\n            if i > 0 {\n                result.WriteRune('_')\n            }\n            result.WriteRune(unicode.ToLower(r))\n        } else {\n            result.WriteRune(r)\n        }\n    }\n    return result.String()\n}\n// Usage\nlit.RegisterModelWithNaming[User](lit.PostgreSQL, PrefixedNamingStrategy{Prefix: \"app_\"})\n// User → app_users","example-no-pluralization#Example: No Pluralization":"type SingularNamingStrategy struct{}\nfunc (SingularNamingStrategy) GetTableNameFromStructName(name string) string {\n    return toSnakeCase(name) // No \"s\" suffix\n}\nfunc (SingularNamingStrategy) GetColumnNameFromStructName(name string) string {\n    return toSnakeCase(name)\n}\n// Usage\nlit.RegisterModelWithNaming[User](lit.PostgreSQL, SingularNamingStrategy{})\n// User → user","example-uppercase-columns#Example: Uppercase Columns":"type UppercaseNamingStrategy struct{}\nfunc (UppercaseNamingStrategy) GetTableNameFromStructName(name string) string {\n    return strings.ToUpper(toSnakeCase(name)) + \"S\"\n}\nfunc (UppercaseNamingStrategy) GetColumnNameFromStructName(name string) string {\n    return strings.ToUpper(toSnakeCase(name))\n}\n// Usage\nlit.RegisterModelWithNaming[User](lit.PostgreSQL, UppercaseNamingStrategy{})\n// User → USERS, FirstName → FIRST_NAME","using-different-strategies-per-model#Using Different Strategies Per Model":"Each model can have its own naming strategy:\n// Default naming for User\nlit.RegisterModel[User](lit.PostgreSQL)\n// User → users\n// Custom naming for LegacyCustomer\nlit.RegisterModelWithNaming[LegacyCustomer](lit.PostgreSQL, PrefixedNamingStrategy{Prefix: \"legacy_\"})\n// LegacyCustomer → legacy_legacy_customers\n// Different strategy for AuditLog\nlit.RegisterModelWithNaming[AuditLog](lit.PostgreSQL, SingularNamingStrategy{})\n// AuditLog → audit_log","common-patterns#Common Patterns":"","match-existing-database-schema#Match Existing Database Schema":"When working with an existing database that doesn't follow snake_case:\ntype ExactNamingStrategy struct {\n    TableName string\n    Columns   map[string]string\n}\nfunc (s ExactNamingStrategy) GetTableNameFromStructName(name string) string {\n    return s.TableName\n}\nfunc (s ExactNamingStrategy) GetColumnNameFromStructName(name string) string {\n    if col, ok := s.Columns[name]; ok {\n        return col\n    }\n    return name\n}\n// Usage for a legacy table \"TBL_USERS\"\nlit.RegisterModelWithNaming[User](lit.PostgreSQL, ExactNamingStrategy{\n    TableName: \"TBL_USERS\",\n    Columns: map[string]string{\n        \"Id\":        \"USER_ID\",\n        \"FirstName\": \"FNAME\",\n        \"LastName\":  \"LNAME\",\n        \"Email\":     \"EMAIL_ADDR\",\n    },\n})"}},"/guides/uuid-support":{"title":"UUID Support","data":{"":"go-lightning supports UUID primary keys through dedicated insert functions.","when-to-use-uuids#When to Use UUIDs":"UUIDs are useful when you need:\nGlobally unique identifiers across systems\nIDs that don't reveal sequence information\nClient-generated IDs before server insertion\nDistributed systems without ID coordination","model-definition#Model Definition":"Define your model with a string ID:\ntype Session struct {\n    Id        string\n    UserId    int\n    Token     string\n    ExpiresAt time.Time\n}\nWhen registering, go-lightning detects that Id is not an integer and sets HasIntId = false. This changes how INSERT queries are generated.","insertuuid#InsertUuid":"Use this when you want go-lightning to generate the UUID:\nfunc InsertUuid[T any](ex Executor, t *T) (string, error)","example#Example":"type Session struct {\n    Id        string\n    UserId    int\n    Token     string\n    ExpiresAt time.Time\n}\nlit.RegisterModel[Session](lit.PostgreSQL)\nsession := Session{\n    UserId:    123,\n    Token:     \"abc123\",\n    ExpiresAt: time.Now().Add(24 * time.Hour),\n}\n// go-lightning generates UUID and sets it on the struct\nuuid, err := lit.InsertUuid(db, &session)\nif err != nil {\n    return err\n}\nfmt.Printf(\"Created session: %s\\n\", uuid)\nfmt.Printf(\"session.Id is also set: %s\\n\", session.Id)\n// Both print the same UUID","how-it-works#How It Works":"Generates a new UUID using github.com/google/uuid\nSets the UUID on the struct's Id field\nExecutes the INSERT with all fields including the ID\nReturns the generated UUID","insertexistinguuid#InsertExistingUuid":"Use this when you already have a UUID:\nfunc InsertExistingUuid[T any](ex Executor, t *T) error","example-1#Example":"session := Session{\n    Id:        \"550e8400-e29b-41d4-a716-446655440000\", // Pre-generated or received from client\n    UserId:    123,\n    Token:     \"abc123\",\n    ExpiresAt: time.Now().Add(24 * time.Hour),\n}\nerr := lit.InsertExistingUuid(db, &session)\nif err != nil {\n    return err\n}","use-cases#Use Cases":"Receiving UUIDs from clients (e.g., offline-first apps)\nMigrating data with existing IDs\nTesting with deterministic IDs\nDistributed ID generation (e.g., from a separate service)","database-schema#Database Schema":"Ensure your database table can store UUIDs:","postgresql#PostgreSQL":"CREATE TABLE sessions (\n    id UUID PRIMARY KEY,\n    user_id INTEGER NOT NULL,\n    token VARCHAR(255) NOT NULL,\n    expires_at TIMESTAMP NOT NULL\n);\nOr with text storage:\nCREATE TABLE sessions (\n    id VARCHAR(36) PRIMARY KEY,\n    user_id INTEGER NOT NULL,\n    token VARCHAR(255) NOT NULL,\n    expires_at TIMESTAMP NOT NULL\n);","mysql#MySQL":"CREATE TABLE sessions (\n    id VARCHAR(36) PRIMARY KEY,\n    user_id INT NOT NULL,\n    token VARCHAR(255) NOT NULL,\n    expires_at DATETIME NOT NULL\n);\nOr with BINARY storage for efficiency:\nCREATE TABLE sessions (\n    id BINARY(16) PRIMARY KEY,\n    user_id INT NOT NULL,\n    token VARCHAR(255) NOT NULL,\n    expires_at DATETIME NOT NULL\n);","complete-example#Complete Example":"package main\nimport (\n    \"database/sql\"\n    \"time\"\n    \"github.com/tracewayapp/go-lightning/lit\"\n    _ \"github.com/lib/pq\"\n)\ntype ApiKey struct {\n    Id        string\n    UserId    int\n    Name      string\n    Key       string\n    CreatedAt time.Time\n}\nfunc init() {\n    lit.RegisterModel[ApiKey](lit.PostgreSQL)\n}\ntype ApiKeyRepository struct{}\nfunc (r *ApiKeyRepository) Create(ex lit.Executor, userId int, name string, key string) (*ApiKey, error) {\n    apiKey := ApiKey{\n        UserId:    userId,\n        Name:      name,\n        Key:       key,\n        CreatedAt: time.Now(),\n    }\n    _, err := lit.InsertUuid(ex, &apiKey)\n    if err != nil {\n        return nil, err\n    }\n    return &apiKey, nil\n}\nfunc (r *ApiKeyRepository) FindById(ex lit.Executor, id string) (*ApiKey, error) {\n    return lit.SelectSingle[ApiKey](ex,\n        \"SELECT id, user_id, name, key, created_at FROM api_keys WHERE id = $1\", id)\n}\nfunc (r *ApiKeyRepository) FindByUserId(ex lit.Executor, userId int) ([]*ApiKey, error) {\n    return lit.Select[ApiKey](ex,\n        \"SELECT id, user_id, name, key, created_at FROM api_keys WHERE user_id = $1\", userId)\n}"}},"/comparison":{"title":"Comparison","data":{"":"How does go-lightning compare to other Go database libraries?","vs-gorm#vs GORM":"GORM is a full-featured ORM with associations, hooks, migrations, and more.\nAspect\tGORM\tgo-lightning\tQuery Builder\tYes, chainable API\tNo, write SQL\tRelationships\tFull support (belongs_to, has_many, etc.)\tNone\tMigrations\tBuilt-in auto-migrate\tNone\tHooks\tBefore/After callbacks\tNone\tQuery Caching\tNo\tYes, at registration\tLearning Curve\tModerate to steep\tMinimal\tDependencies\tHeavy\tMinimal\t\nChoose go-lightning if: You want simplicity, full SQL control, and minimal overhead.Choose GORM if: You need relationship management, auto-migrations, or an ActiveRecord-style API.","code-comparison#Code Comparison":"// GORM\ndb.Where(\"email = ?\", email).First(&user)\ndb.Create(&user)\ndb.Save(&user)\n// go-lightning\nlit.SelectSingle[User](db, \"SELECT id, name, email FROM users WHERE email = $1\", email)\nlit.Insert(db, &user)\nlit.Update(db, &user, \"id = $1\", user.Id)","vs-sqlx#vs sqlx":"sqlx extends database/sql with struct scanning and named parameters.\nAspect\tsqlx\tgo-lightning\tStruct Scanning\tYes, via tags\tYes, via registration\tNamed Parameters\tYes\tNo\tINSERT Generation\tNo\tYes\tUPDATE Generation\tNo\tYes\tReflection\tEvery query\tOnce at registration\tQuery Caching\tNo\tYes\t\nChoose go-lightning if: You want auto-generated INSERT/UPDATE with cached queries.Choose sqlx if: You need named parameters or prefer struct tags over registration.","code-comparison-1#Code Comparison":"// sqlx - requires writing INSERT manually\ntype User struct {\n    Id    int    `db:\"id\"`\n    Name  string `db:\"name\"`\n    Email string `db:\"email\"`\n}\ndb.Get(&user, \"SELECT * FROM users WHERE id = $1\", id)\ndb.Exec(\"INSERT INTO users (name, email) VALUES ($1, $2)\", user.Name, user.Email)\n// go-lightning - INSERT is auto-generated\ntype User struct {\n    Id    int\n    Name  string\n    Email string\n}\nlit.RegisterModel[User](lit.PostgreSQL)\nlit.SelectSingle[User](db, \"SELECT id, name, email FROM users WHERE id = $1\", id)\nlit.Insert(db, &user) // Query pre-generated","vs-sqlc#vs sqlc":"sqlc generates type-safe Go code from SQL queries.\nAspect\tsqlc\tgo-lightning\tCode Generation\tYes, required\tNo\tBuild Step\tYes\tNo\tType Safety\tCompile-time\tRuntime\tQuery Changes\tRegenerate code\tUpdate SQL string\tIDE Support\tFull (generated types)\tStandard Go\tRuntime Flexibility\tNone\tFull\t\nChoose go-lightning if: You want runtime flexibility without a build step.Choose sqlc if: You want compile-time type safety and don't mind code generation.","workflow-comparison#Workflow Comparison":"# sqlc workflow\n1. Write SQL in .sql files\n2. Run `sqlc generate`\n3. Use generated Go functions\n4. Repeat on query changes\n# go-lightning workflow\n1. Define Go struct\n2. Register model\n3. Write SQL in Go code\n4. No regeneration needed","vs-ent#vs ent":"ent is a code-generation based ORM with a graph-based API.\nAspect\tent\tgo-lightning\tCode Generation\tHeavy (entire data layer)\tNone\tSchema Definition\tGo code with DSL\tPlain Go structs\tRelationships\tFirst-class support\tNone\tGraph Traversal\tYes\tNo\tMigrations\tAuto-generated\tNone\tLearning Curve\tSteep\tMinimal\t\nChoose go-lightning if: You want simplicity and no code generation.Choose ent if: You need graph-style queries and relationships.","schema-comparison#Schema Comparison":"// ent - schema definition DSL\nfunc (User) Fields() []ent.Field {\n    return []ent.Field{\n        field.String(\"name\"),\n        field.String(\"email\").Unique(),\n    }\n}\nfunc (User) Edges() []ent.Edge {\n    return []ent.Edge{\n        edge.To(\"posts\", Post.Type),\n    }\n}\n// go-lightning - plain struct\ntype User struct {\n    Id    int\n    Name  string\n    Email string\n}","summary-table#Summary Table":"Feature\tgo-lightning\tGORM\tsqlx\tsqlc\tent\tCode Generation\tNone\tNone\tNone\tRequired\tRequired\tBuild Step\tNo\tNo\tNo\tYes\tYes\tQuery Caching\tYes\tNo\tNo\tN/A\tNo\tINSERT/UPDATE Gen\tYes\tYes\tNo\tYes\tYes\tRelationships\tNo\tYes\tNo\tNo\tYes\tMigrations\tNo\tYes\tNo\tNo\tYes\tDependencies\tMinimal\tHeavy\tLight\tNone\tHeavy\tLearning Curve\tLow\tMedium\tLow\tMedium\tHigh\tSQL Control\tFull\tPartial\tFull\tFull\tPartial","when-to-choose-go-lightning#When to Choose go-lightning":"go-lightning is ideal when you:\nWant to write your own SQL\nDon't need relationship mapping\nValue simplicity over features\nWant minimal dependencies\nNeed fast startup and runtime performance\nPrefer no code generation step\nAre building microservices or APIs with straightforward data access"}},"/core-concepts/mutations":{"title":"Mutations","data":{"":"go-lightning provides functions for creating, updating, and deleting data.","insert#Insert":"Insert a new record and get the generated ID:\nfunc Insert[T any](ex Executor, t *T) (int, error)","example#Example":"user := User{\n    FirstName: \"John\",\n    LastName:  \"Doe\",\n    Email:     \"john@example.com\",\n}\nid, err := lit.Insert(db, &user)\nif err != nil {\n    return err\n}\nfmt.Printf(\"Created user with ID: %d\\n\", id)\nThe INSERT query is pre-generated during registration, so this operation has minimal overhead.","insert-with-uuid#Insert with UUID":"For models with string/UUID IDs, use one of these functions:","insertuuid#InsertUuid":"Generates a new UUID automatically:\nfunc InsertUuid[T any](ex Executor, t *T) (string, error)\ntype Session struct {\n    Id        string\n    UserId    int\n    ExpiresAt time.Time\n}\nlit.RegisterModel[Session](lit.PostgreSQL)\nsession := Session{\n    UserId:    123,\n    ExpiresAt: time.Now().Add(24 * time.Hour),\n}\nuuid, err := lit.InsertUuid(db, &session)\n// uuid = \"550e8400-e29b-41d4-a716-446655440000\"\n// session.Id is also set to this value","insertexistinguuid#InsertExistingUuid":"Use when you already have a UUID:\nfunc InsertExistingUuid[T any](ex Executor, t *T) error\nsession := Session{\n    Id:        \"my-existing-uuid\",\n    UserId:    123,\n    ExpiresAt: time.Now().Add(24 * time.Hour),\n}\nerr := lit.InsertExistingUuid(db, &session)\nSee UUID Support for more details.","update#Update":"Update a record with a WHERE clause:\nfunc Update[T any](ex Executor, t *T, where string, args ...any) error\nImportant: The where parameter is required and cannot be empty. This prevents accidental updates to all rows.","example-1#Example":"user.FirstName = \"Jane\"\nuser.Email = \"jane@example.com\"\nerr := lit.Update(db, &user, \"id = $1\", user.Id)\nThe UPDATE query base is pre-generated. The WHERE clause is appended at runtime.","postgresql-placeholder-handling#PostgreSQL Placeholder Handling":"For PostgreSQL, placeholders in your WHERE clause are automatically renumbered:\n// Your code\nlit.Update(db, &user, \"id = $1 AND active = $2\", user.Id, true)\n// Executed query (if User has 4 fields):\n// UPDATE users SET id = $1, first_name = $2, last_name = $3, email = $4 WHERE id = $5 AND active = $6","delete#Delete":"Delete uses manual SQL for full control:\nfunc Delete(ex Executor, query string, args ...any) error","example-2#Example":"// Delete single\nerr := lit.Delete(db, \"DELETE FROM users WHERE id = $1\", userId)\n// Delete multiple\nerr := lit.Delete(db, \"DELETE FROM users WHERE last_login < $1\", cutoffDate)\n// Delete with IN clause\nids := []int{1, 2, 3}\nerr := lit.Delete(db,\n    \"DELETE FROM users WHERE id IN (\"+lit.JoinForIn(ids)+\")\")","in-clause-helpers#IN Clause Helpers":"go-lightning provides helpers for building IN clauses:","joinforin#JoinForIn":"For integer slices:\nfunc JoinForIn(ids []int) string\nids := []int{1, 2, 3, 4, 5}\nquery := \"SELECT * FROM users WHERE id IN (\" + lit.JoinForIn(ids) + \")\"\n// Result: SELECT * FROM users WHERE id IN (1,2,3,4,5)","joinstringforin#JoinStringForIn":"For parameterized IN clauses with strings:\nfunc JoinStringForIn[T any](offset int, params []string) string\nemails := []string{\"a@test.com\", \"b@test.com\"}\n// PostgreSQL (offset=0)\nquery := \"SELECT * FROM users WHERE email IN (\" + lit.JoinStringForIn[User](0, emails) + \")\"\n// Result: SELECT * FROM users WHERE email IN ($1,$2)\n// MySQL\nquery := \"SELECT * FROM users WHERE email IN (\" + lit.JoinStringForIn[User](0, emails) + \")\"\n// Result: SELECT * FROM users WHERE email IN (?,?)","joinstringforinwithdriver#JoinStringForInWithDriver":"When you don't have a registered model:\nfunc JoinStringForInWithDriver(driver Driver, offset int, count int) string\nplaceholders := lit.JoinStringForInWithDriver(lit.PostgreSQL, 0, 3)\n// Result: $1,$2,$3","native-operations#Native Operations":"For cases where auto-generated queries don't fit:","insertnative#InsertNative":"func InsertNative(ex Executor, query string, args ...any) (int, error)\nid, err := lit.InsertNative(db,\n    \"INSERT INTO audit_log (action, timestamp) VALUES ($1, $2) RETURNING id\",\n    \"user_login\", time.Now())","updatenative#UpdateNative":"func UpdateNative(ex Executor, query string, args ...any) error\nerr := lit.UpdateNative(db,\n    \"UPDATE counters SET value = value + 1 WHERE name = $1\",\n    \"page_views\")"}},"/core-concepts/registration":{"title":"Registration","data":{"":"Registration is the foundation of go-lightning's performance. By registering models at startup, all reflection and query generation happens once, not on every database operation.","why-registration-exists#Why Registration Exists":"Traditional ORMs use reflection on every query to map struct fields to database columns. This adds overhead to every operation. go-lightning takes a different approach:\nRegister once at application startup\nUse cached data for all subsequent operations\nMinimal reflection overhead during queries","basic-registration#Basic Registration":"import \"github.com/tracewayapp/go-lightning/lit\"\ntype User struct {\n    Id        int\n    FirstName string\n    LastName  string\n    Email     string\n}\nfunc init() {\n    lit.RegisterModel[User](lit.PostgreSQL)\n}","what-gets-cached#What Gets Cached":"When you call RegisterModel, go-lightning creates a FieldMap containing:\nField\tDescription\tColumnsMap\tMaps column names to field positions\tColumnKeys\tOrdered list of column names\tHasIntId\tWhether id field is an integer (for auto-increment)\tInsertQuery\tPre-built INSERT statement\tUpdateQuery\tPre-built UPDATE statement (without WHERE clause)\tInsertColumns\tColumns used in INSERT (excludes auto-increment id)\tDriver\tDatabase driver (PostgreSQL or MySQL)","default-naming-convention#Default Naming Convention":"go-lightning converts Go's CamelCase to SQL's snake_case:\nGo Field\tSQL Column\tId\tid\tFirstName\tfirst_name\tLastName\tlast_name\tCreatedAt\tcreated_at\tUserID\tuser_i_d\t\nTable names are derived from struct names with an s suffix:\nUser → users\nProduct → products","id-detection#ID Detection":"go-lightning automatically detects if your id field is an integer:\n// Integer ID - uses DEFAULT in INSERT, RETURNING id (PostgreSQL) or LastInsertId (MySQL)\ntype User struct {\n    Id   int    // HasIntId = true\n    Name string\n}\n// String/UUID ID - includes id in INSERT values\ntype Session struct {\n    Id   string  // HasIntId = false\n    Data string\n}","custom-naming-strategy#Custom Naming Strategy":"For different naming conventions, use RegisterModelWithNaming:\ntype MyNamingStrategy struct{}\nfunc (MyNamingStrategy) GetTableNameFromStructName(name string) string {\n    return \"tbl_\" + strings.ToLower(name)\n}\nfunc (MyNamingStrategy) GetColumnNameFromStructName(name string) string {\n    return strings.ToLower(name)\n}\nfunc init() {\n    lit.RegisterModelWithNaming[User](lit.PostgreSQL, MyNamingStrategy{})\n}\nSee Naming Strategies for more details.","generated-queries-example#Generated Queries Example":"For a registered User struct with PostgreSQL:INSERT Query:\nINSERT INTO users (id,first_name,last_name,email) VALUES (DEFAULT,$1,$2,$3) RETURNING id\nUPDATE Query (base):\nUPDATE users SET id = $1,first_name = $2,last_name = $3,email = $4 WHERE\nThe WHERE clause is appended at runtime when you call Update()."}},"/guides/projections":{"title":"Projections & DTOs","data":{"":"go-lightning can map query results to any registered struct, not just your main models. This enables DTOs (Data Transfer Objects) for partial selects, JOINs, and aggregations.","why-use-projections#Why Use Projections?":"Performance: Select only the columns you need\nJOINs: Combine data from multiple tables into one struct\nAggregations: Map COUNT, SUM, AVG results to structs\nAPI Responses: Shape data for specific endpoints\nSecurity: Exclude sensitive fields from query results","basic-projection#Basic Projection":"Select a subset of columns:\n// Full model\ntype User struct {\n    Id           int\n    FirstName    string\n    LastName     string\n    Email        string\n    PasswordHash string\n    CreatedAt    time.Time\n    UpdatedAt    time.Time\n}\n// DTO with only public fields\ntype UserPublic struct {\n    Id        int\n    FirstName string\n    LastName  string\n    Email     string\n}\nfunc init() {\n    lit.RegisterModel[User](lit.PostgreSQL)\n    lit.RegisterModel[UserPublic](lit.PostgreSQL)\n}\n// Use the projection\nusers, err := lit.Select[UserPublic](db,\n    \"SELECT id, first_name, last_name, email FROM users\")\n// Returns []*UserPublic without password_hash, created_at, updated_at","join-projections#JOIN Projections":"Combine data from multiple tables:\ntype OrderWithCustomer struct {\n    OrderId      int\n    OrderDate    time.Time\n    Total        float64\n    CustomerName string\n    CustomerEmail string\n}\nlit.RegisterModel[OrderWithCustomer](lit.PostgreSQL)\nresults, err := lit.Select[OrderWithCustomer](db, `\n    SELECT\n        o.id as order_id,\n        o.order_date,\n        o.total,\n        c.name as customer_name,\n        c.email as customer_email\n    FROM orders o\n    JOIN customers c ON c.id = o.customer_id\n    WHERE o.order_date > $1\n`, startDate)","important-column-aliases#Important: Column Aliases":"Use SQL aliases (AS) to match your struct field names:\no.id → order_id (matches OrderId field)\nc.name → customer_name (matches CustomerName field)","aggregation-projections#Aggregation Projections":"type CategoryStats struct {\n    CategoryId   int\n    CategoryName string\n    ProductCount int\n    AvgPrice     float64\n    TotalRevenue float64\n}\nlit.RegisterModel[CategoryStats](lit.PostgreSQL)\nstats, err := lit.Select[CategoryStats](db, `\n    SELECT\n        c.id as category_id,\n        c.name as category_name,\n        COUNT(p.id) as product_count,\n        AVG(p.price) as avg_price,\n        SUM(p.price * p.units_sold) as total_revenue\n    FROM categories c\n    LEFT JOIN products p ON p.category_id = c.id\n    GROUP BY c.id, c.name\n    ORDER BY total_revenue DESC\n`)","nested-data-with-multiple-queries#Nested Data with Multiple Queries":"For complex nested structures, use multiple queries:\ntype UserWithOrders struct {\n    User   *User\n    Orders []*Order\n}\nfunc GetUserWithOrders(db *sql.DB, userId int) (*UserWithOrders, error) {\n    user, err := lit.SelectSingle[User](db,\n        \"SELECT id, first_name, last_name, email FROM users WHERE id = $1\", userId)\n    if err != nil {\n        return nil, err\n    }\n    if user == nil {\n        return nil, nil\n    }\n    orders, err := lit.Select[Order](db,\n        \"SELECT id, user_id, total, status, created_at FROM orders WHERE user_id = $1\", userId)\n    if err != nil {\n        return nil, err\n    }\n    return &UserWithOrders{User: user, Orders: orders}, nil\n}","pagination-dto#Pagination DTO":"type PaginatedUsers struct {\n    Users      []*UserPublic\n    TotalCount int\n    Page       int\n    PageSize   int\n}\ntype CountResult struct {\n    Count int\n}\nlit.RegisterModel[CountResult](lit.PostgreSQL)\nfunc GetPaginatedUsers(db *sql.DB, page, pageSize int) (*PaginatedUsers, error) {\n    offset := (page - 1) * pageSize\n    // Get total count\n    countResult, err := lit.SelectSingle[CountResult](db,\n        \"SELECT COUNT(*) as count FROM users\")\n    if err != nil {\n        return nil, err\n    }\n    // Get page of users\n    users, err := lit.Select[UserPublic](db,\n        \"SELECT id, first_name, last_name, email FROM users ORDER BY id LIMIT $1 OFFSET $2\",\n        pageSize, offset)\n    if err != nil {\n        return nil, err\n    }\n    return &PaginatedUsers{\n        Users:      users,\n        TotalCount: countResult.Count,\n        Page:       page,\n        PageSize:   pageSize,\n    }, nil\n}","search-results#Search Results":"type UserSearchResult struct {\n    Id        int\n    FirstName string\n    LastName  string\n    Email     string\n    MatchType string // \"email\" or \"name\"\n}\nlit.RegisterModel[UserSearchResult](lit.PostgreSQL)\nfunc SearchUsers(db *sql.DB, query string) ([]*UserSearchResult, error) {\n    searchPattern := \"%\" + query + \"%\"\n    return lit.Select[UserSearchResult](db, `\n        SELECT\n            id,\n            first_name,\n            last_name,\n            email,\n            CASE\n                WHEN email ILIKE $1 THEN 'email'\n                ELSE 'name'\n            END as match_type\n        FROM users\n        WHERE email ILIKE $1\n           OR first_name ILIKE $1\n           OR last_name ILIKE $1\n        ORDER BY\n            CASE WHEN email ILIKE $1 THEN 0 ELSE 1 END,\n            first_name\n    `, searchPattern)\n}","tips#Tips":"Register all DTOs: Each struct you use with Select or SelectSingle must be registered\nMatch column names: SQL column names (or aliases) must match your struct field names after snake_case conversion\nColumn validation: go-lightning validates columns at runtime and returns clear errors for mismatches\nReuse DTOs: Create a dto package for shared projection types\nKeep it simple: If a projection is only used once, consider if it's worth the extra type"}},"/":{"title":"go-lightning","data":{"":"A lightweight, high-performance database library for Go that prioritizes simplicity and speed.","why-go-lightning#Why go-lightning?":"","easy-to-use#Easy to Use":"Simple API with minimal learning curve. Define a struct, register it, and start querying. No complex configurations or setup required.","cached-queries#Cached Queries":"INSERT and UPDATE statements are pre-computed at registration time. Zero runtime overhead for query generation—everything is ready when you need it.","sql-first#SQL-First":"Write your own SQL queries. No magic query builders or DSLs to learn. Full control over your database operations with raw SQL.","insertupdate-out-of-the-box#Insert/Update Out of the Box":"Auto-generated INSERT and UPDATE statements from your struct definition. No boilerplate code for basic CRUD operations.","lightweight#Lightweight":"Minimal dependencies, small footprint. Only imports database/sql and github.com/google/uuid. No heavy ORM frameworks.","no-code-generation#No Code Generation":"Unlike sqlc or ent, there's no build step required. No generated files to maintain. Just import and use.","no-relationship-mapping#No Relationship Mapping":"Explicit over implicit. No hidden JOINs or lazy loading. You control exactly what queries run against your database.","parse-to-any-struct#Parse to Any Struct":"Project any query result to any DTO. Not limited to your registered models—query complex JOINs and map to custom structs.","quick-example#Quick Example":"package main\nimport (\n    \"database/sql\"\n    \"github.com/tracewayapp/go-lightning/lit\"\n    _ \"github.com/lib/pq\"\n)\n// Define your model\ntype User struct {\n    Id        int\n    FirstName string\n    LastName  string\n    Email     string\n}\nfunc main() {\n    // Register the model (happens once at startup)\n    lit.RegisterModel[User](lit.PostgreSQL)\n    // Connect to database\n    db, _ := sql.Open(\"postgres\", \"postgres://localhost/mydb?sslmode=disable\")\n    // Create\n    user := User{FirstName: \"John\", LastName: \"Doe\", Email: \"john@example.com\"}\n    id, _ := lit.Insert(db, &user)\n    // Read\n    users, _ := lit.Select[User](db, \"SELECT id, first_name, last_name, email FROM users\")\n    // Read single\n    user, _ := lit.SelectSingle[User](db, \"SELECT id, first_name, last_name, email FROM users WHERE id = $1\", id)\n    // Update\n    user.FirstName = \"Jane\"\n    lit.Update(db, &user, \"id = $1\", user.Id)\n    // Delete\n    lit.Delete(db, \"DELETE FROM users WHERE id = $1\", id)\n}","get-started#Get Started":"Ready to use go-lightning? Follow the installation guide or jump straight to the quick start."}}}